
[match:syntax]
M1: """# EBNF-Grammar in EBNF

    @ comment    = /#.*(?:\n|$)/                    # comments start with '#' and eat all chars up to and including '\n'
    @ whitespace = /\s*/                            # whitespace includes linefeed
    @ literalws  = right                            # trailing whitespace of literals will be ignored tacitly
    @ drop       = whitespace                       # do not include whitespace in concrete syntax tree

    #: top-level

    syntax     = [~//] { definition | directive } §EOF
    definition = symbol §"=" expression
    directive  = "@" §symbol "=" (regexp | literal | symbol) { "," (regexp | literal | symbol) }

    #: components

    expression = sequence { "|" sequence }
    sequence   = { ["§"] term }+                         # "§" means all following terms mandatory
    term       = [flowmarker] [retrieveop] symbol !"="   # negative lookahead to be sure it's not a definition
               | [flowmarker] literal
               | [flowmarker] plaintext
               | [flowmarker] regexp
               | [flowmarker] whitespace
               | [flowmarker] oneormore
               | [flowmarker] group
               | [flowmarker] unordered
               | repetition
               | option

    #: flow-operators

    flowmarker = "!"  | "&"                         # '!' negative lookahead, '&' positive lookahead
               | "-!" | "-&"                        # '-' negative lookbehind, '-&' positive lookbehind
    retrieveop = "::" | ":?" | ":"                  # '::' pop, ':?' optional pop, ':' retrieve

    #: groups

    group      = "(" §expression ")"
    unordered  = "<" §expression ">"                # elements of expression in arbitrary order
    oneormore  = "{" expression "}+"
    repetition = "{" §expression "}"
    option     = "[" §expression "]"

    #: leaf-elements

    symbol     = /(?!\d)\w+/~                       # e.g. expression, term, parameter_list
    literal    = /"(?:(?<!\\)\\"|[^"])*?"/~         # e.g. "(", '+', 'while'
               | /'(?:(?<!\\)\\'|[^'])*?'/~         # whitespace following literals will be ignored tacitly.
    plaintext  = /`(?:(?<!\\)\\`|[^`])*?`/~         # like literal but does not eat whitespace
    regexp     = /\/(?:(?<!\\)\\(?:\/)|[^\/])*?\//~     # e.g. /\w+/, ~/#.*(?:\n|$)/~
    whitespace = /~/~                               # insignificant whitespace

    EOF = !/./"""
M5: '''
    @ comment    = /(?!#x[A-Fa-f0-9])#.*(?:\n|$)|\/\*(?:.|\n)*?\*\/|\(\*(?:.|\n)*?\*\)/
        # comments can be either C-Style: /* ... */
        # or pascal/modula/oberon-style: (* ... *)
        # or python-style: # ... \n, excluding, however, character markers: #x20
    @ whitespace = /\s*/                            # whitespace includes linefeed
    @ literalws  = right                            # trailing whitespace of literals will be ignored tacitly
    @ disposable = component, pure_elem, countable, FOLLOW_UP, SYM_REGEX, ANY_SUFFIX, EOF
    @ drop       = whitespace, EOF                  # do not include these even in the concrete syntax tree
    @ RNG_BRACE_filter = matching_bracket()         # filter or transform content of RNG_BRACE on retrieve

    # re-entry-rules for resuming after parsing-error

    @ definition_resume = /\n\s*(?=@|\w+\w*\s*=)/
    @ directive_resume  = /\n\s*(?=@|\w+\w*\s*=)/

    # specialized error messages for certain cases

    @ definition_error  = /,/, 'Delimiter "," not expected in definition!\nEither this was meant to '
                               'be a directive and the directive symbol @ is missing\nor the error is '
                               'due to inconsistent use of the comma as a delimiter\nfor the elements '
                               'of a sequence.'

    #: top-level

    syntax     = ~ { definition | directive } EOF
    definition = symbol §DEF~ [ OR~ ] expression ENDL~ & FOLLOW_UP  # [OR~] to support v. Rossum's syntax

    directive  = "@" §symbol "=" component { "," component } & FOLLOW_UP
      # component  = (regexp | literals | procedure | symbol !DEF)
      component  = literals | procedure | expression
      literals   = { literal }+                       # string chaining, only allowed in directives!
      procedure  = SYM_REGEX "()"                     # procedure name, only allowed in directives!

    FOLLOW_UP  = `@` | symbol | EOF


    #: components

    expression = sequence { OR~ sequence }
    sequence   = ["§"] ( interleave | lookaround )  # "§" means all following terms mandatory
                 { AND~ ["§"] ( interleave | lookaround ) }
    interleave = difference { "°" ["§"] difference }
    lookaround = flowmarker § (oneormore | pure_elem)
    difference = term ["-" § (oneormore | pure_elem)]
    term       = oneormore | counted | repetition | option | pure_elem


    #: elements

    countable  = option | oneormore | element
    pure_elem  = element § !ANY_SUFFIX              # element strictly without a suffix
    element    = [retrieveop] symbol !DEF          # negative lookahead to be sure it's not a definition
               | literal
               | plaintext
               | regexp
               # | char_range
               | character ~
               | any_char
               | whitespace
               | group


    ANY_SUFFIX = /[?*+]/


    #: flow-operators

    flowmarker = "!"  | "&"                         # '!' negative lookahead, '&' positive lookahead
               | "<-!" | "<-&"                      # '<-!' negative lookbehind, '<-&' positive lookbehind
    retrieveop = "::" | ":?" | ":"                  # '::' pop, ':?' optional pop, ':' retrieve


    #: groups

    group      = "(" no_range §expression ")"
    oneormore  = "{" no_range expression "}+" | element "+"
    repetition = "{" no_range §expression "}" | element "*" no_range
    option     = # !char_range
                 "[" §expression "]" | element "?"
    counted    = countable range | countable TIMES~ multiplier | multiplier TIMES~ §countable

    range      = RNG_OPEN~ multiplier [ RNG_DELIM~ multiplier ] RNG_CLOSE~
    no_range   = !multiplier | &multiplier TIMES
    multiplier = /[1-9]\d*/~


    #: leaf-elements

    symbol     = SYM_REGEX ~                        # e.g. expression, term, parameter_list
    literal    = /"(?:(?<!\\)\\"|[^"])*?"/~         # e.g. "(", '+', 'while'
               | /'(?:(?<!\\)\\'|[^'])*?'/~         # whitespace following literals will be ignored tacitly.
    plaintext  = /`(?:(?<!\\)\\`|[^`])*?`/~         # like literal but does not eat whitespace
               | /´(?:(?<!\\)\\´|[^´])*?´/~
    regexp     = RE_LEADIN RE_CORE RE_LEADOUT ~   # e.g. /\w+/, ~/#.*(?:\n|$)/~
    # regexp     = /\/(?:(?<!\\)\\(?:\/)|[^\/])*?\//~     # e.g. /\w+/, ~/#.*(?:\n|$)/~
    char_range = `[` &char_range_heuristics
                     [`^`] (character | free_char) { [`-`] character | free_char } "]"
    character  = CH_LEADIN HEXCODE
    free_char  = /[^\n\[\]\\]/ | /\\[nrt`´'"(){}\[\]\/\\]/
    any_char   = "."
    whitespace = /~/~                               # insignificant whitespace

    #: delimiters

    EOF = !/./

    DEF        = `=`
    OR         = `|`
    AND        = ``
    ENDL       = ``

    RNG_OPEN   = `{`
    RNG_CLOSE  = `}`
    RNG_DELIM  = `,`
    TIMES      = `*`

    RE_LEADIN  = `/`
    RE_LEADOUT = `/`

    CH_LEADIN  = `0x`

    #: heuristics

    char_range_heuristics  = ! ( /[\n\t ]/
                               | ~ literal_heuristics
                               | [`::`|`:?`|`:`] SYM_REGEX /\s*\]/ )
    literal_heuristics     = /~?\s*"(?:[\\]\]|[^\]]|[^\\]\[[^"]*)*"/
                           | /~?\s*'(?:[\\]\]|[^\]]|[^\\]\[[^']*)*'/
                           | /~?\s*`(?:[\\]\]|[^\]]|[^\\]\[[^`]*)*`/
                           | /~?\s*´(?:[\\]\]|[^\]]|[^\\]\[[^´]*)*´/
                           | /~?\s*\/(?:[\\]\]|[^\]]|[^\\]\[[^\/]*)*\//
    regex_heuristics       = /[^ ]/ | /[^\/\n*?+\\]*[*?+\\][^\/\n]\//


    #: basic-regexes

    RE_CORE    = /(?:(?<!\\)\\(?:\/)|[^\/])*/       # core of a regular expression, i.e. the dots in /.../
    SYM_REGEX  = /(?!\d)\w+/                        # regular expression for symbols
    HEXCODE    = /[A-Fa-f0-9]{1,8}/
    '''
M6: '''
    @ comment    = /(?!#x[A-Fa-f0-9])#.*(?:\n|$)|\/\*(?:.|\n)*?\*\/|\(\*(?:.|\n)*?\*\)/
        # comments can be either C-Style: /* ... */
        # or pascal/modula/oberon-style: (* ... *)
        # or python-style: # ... \n, excluding, however, character markers: #x20
    @ whitespace = /\s*/                            # whitespace includes linefeed
    @ literalws  = right                            # trailing whitespace of literals will be ignored tacitly
    @ disposable = component, pure_elem, countable, FOLLOW_UP, SYM_REGEX, ANY_SUFFIX, EOF
    @ drop       = whitespace, EOF                  # do not include these even in the concrete syntax tree
    @ RNG_BRACE_filter = matching_bracket()         # filter or transform content of RNG_BRACE on retrieve

    # re-entry-rules for resuming after parsing-error

    @ definition_resume = /\n\s*(?=@|\w+\w*\s*=)/
    @ directive_resume  = /\n\s*(?=@|\w+\w*\s*=)/


    # specialized error messages for certain cases

    @ definition_error  = /,/, 'Delimiter "," not expected in definition!\nEither this was meant to '
                               'be a directive and the directive symbol @ is missing\nor the error is '
                               'due to inconsistent use of the comma as a delimiter\nfor the elements '
                               'of a sequence.'


    #: top-level

    syntax     = ~ { definition | directive } EOF
    definition = symbol §:DEF~ [ :OR~ ] expression :ENDL~ & FOLLOW_UP  # [:OR~] to support v. Rossum's syntax

    directive  = "@" §symbol "=" component { "," component } & FOLLOW_UP
      # component  = (regexp | literals | procedure | symbol !DEF)
      component  = literals | procedure | expression
      literals   = { literal }+                       # string chaining, only allowed in directives!
      procedure  = SYM_REGEX "()"                     # procedure name, only allowed in directives!

    FOLLOW_UP  = `@` | symbol | EOF


    #: components

    expression = sequence { :OR~ sequence }
    sequence   = ["§"] ( interleave | lookaround )  # "§" means all following terms mandatory
                 { !`@` !(symbol :DEF) :AND~ ["§"] ( interleave | lookaround ) }
    interleave = difference { "°" ["§"] difference }
    lookaround = flowmarker § (oneormore | pure_elem)
    difference = term ["-" § (oneormore | pure_elem)]
    term       = oneormore | counted | repetition | option | pure_elem


    #: elements

    countable  = option | oneormore | element
    pure_elem  = element § !ANY_SUFFIX              # element strictly without a suffix
    element    = [retrieveop] symbol !:DEF          # negative lookahead to be sure it's not a definition
               | literal
               | plaintext
               | regexp
               | char_range
               | character ~
               | any_char
               | whitespace
               | group


    ANY_SUFFIX = /[?*+]/


    #: flow-operators

    flowmarker = "!"  | "&"                         # '!' negative lookahead, '&' positive lookahead
               | "<-!" | "<-&"                      # '<-!' negative lookbehind, '<-&' positive lookbehind
    retrieveop = "::" | ":?" | ":"                  # '::' pop, ':?' optional pop, ':' retrieve


    #: groups

    group      = "(" no_range §expression ")"
    oneormore  = "{" no_range expression "}+" | element "+"
    repetition = "{" no_range §expression "}" | element "*" no_range
    option     = !char_range "[" §expression "]" | element "?"
    counted    = countable range | countable :TIMES~ multiplier | multiplier :TIMES~ §countable

    range      = RNG_BRACE~ multiplier [ :RNG_DELIM~ multiplier ] ::RNG_BRACE~
    no_range   = !multiplier | &multiplier :TIMES
    multiplier = /[1-9]\d*/~


    #: leaf-elements

    symbol     = SYM_REGEX ~                        # e.g. expression, term, parameter_list
    literal    = /"(?:(?<!\\)\\"|[^"])*?"/~         # e.g. "(", '+', 'while'
               | /'(?:(?<!\\)\\'|[^'])*?'/~         # whitespace following literals will be ignored tacitly.
    plaintext  = /`(?:(?<!\\)\\`|[^`])*?`/~         # like literal but does not eat whitespace
               | /´(?:(?<!\\)\\´|[^´])*?´/~
    regexp     = :RE_LEADIN RE_CORE :RE_LEADOUT ~   # e.g. /\w+/, ~/#.*(?:\n|$)/~
    # regexp     = /\/(?:(?<!\\)\\(?:\/)|[^\/])*?\//~     # e.g. /\w+/, ~/#.*(?:\n|$)/~
    char_range = `[` &char_range_heuristics
                     [`^`] (character | free_char) { [`-`] character | free_char } "]"
    character  = :CH_LEADIN HEXCODE
    free_char  = /[^\n\[\]\\]/ | /\\[nrt`´'"(){}\[\]\/\\]/
    any_char   = "."
    whitespace = /~/~                               # insignificant whitespace

    #: delimiters

    EOF = !/./ [:?DEF] [:?OR] [:?AND] [:?ENDL]      # [:?DEF], [:?OR], ... clear stack by eating stored value
               [:?RNG_DELIM] [:?BRACE_SIGN] [:?CH_LEADIN] [:?TIMES] [:?RE_LEADIN] [:?RE_LEADOUT]

    DEF        = `=` | `:=` | `::=` | `<-` | /:\n/ | `: `  # with `: `, retrieve markers mustn't be followed by a blank!
    OR         = `|` | `/` !regex_heuristics
    AND        = `,` | ``
    ENDL       = `;` | ``

    RNG_BRACE  = :BRACE_SIGN
    BRACE_SIGN = `{` | `(`
    RNG_DELIM  = `,`
    TIMES      = `*`

    RE_LEADIN  = `/` &regex_heuristics | `^/`
    RE_LEADOUT = `/`

    CH_LEADIN  = `0x` | `#x`

    #: heuristics

    char_range_heuristics  = ! ( /[\n\t ]/
                               | ~ literal_heuristics
                               | [`::`|`:?`|`:`] SYM_REGEX /\s*\]/ )
    literal_heuristics     = /~?\s*"(?:[\\]\]|[^\]]|[^\\]\[[^"]*)*"/
                           | /~?\s*'(?:[\\]\]|[^\]]|[^\\]\[[^']*)*'/
                           | /~?\s*`(?:[\\]\]|[^\]]|[^\\]\[[^`]*)*`/
                           | /~?\s*´(?:[\\]\]|[^\]]|[^\\]\[[^´]*)*´/
                           | /~?\s*\/(?:[\\]\]|[^\]]|[^\\]\[[^\/]*)*\//
    regex_heuristics       = /[^ ]/ | /[^\/\n*?+\\]*[*?+\\][^\/\n]\//


    #: basic-regexes

    RE_CORE    = /(?:(?<!\\)\\(?:\/)|[^\/])*/       # core of a regular expression, i.e. the dots in /.../
    SYM_REGEX  = /(?!\d)\w+/                        # regular expression for symbols
    HEXCODE    = /[A-Fa-f0-9]{1,8}/
    '''

[ast:syntax]

[fail:syntax]


[match:definition]

[ast:definition]

[fail:definition]


[match:directive]

[ast:directive]

[fail:directive]


[match:component]

[ast:component]

[fail:component]


[match:literals]

[ast:literals]

[fail:literals]


[match:procedure]

[ast:procedure]

[fail:procedure]


[match:FOLLOW_UP]

[ast:FOLLOW_UP]

[fail:FOLLOW_UP]

