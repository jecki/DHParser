# re-grammar

#######################################################################
#
#  EBNF-Directives
#
#######################################################################

# Regular expression for implicit whitespace or one of: horizontal, linefeed, vertical
# Implicit whitespace is denoted by the tilde-character: ~
@ whitespace  = vertical

# Implicit whitespace adjacent to literals: left, right, both, none
# E.g. if @literalws = right then ")" means the same as `)`~
@ literalws   = none

# Regular expression for comments, e.g. /#.*(?:\n|$)/
# Use: /(?:\/\/.*)|(?:\/\*(?:.|\n)*?\*\/)/ for C++-style comments: /* ... */ or // to EOL
@ comment     = /#.*/

# Case-sensitivity: True, False
@ ignorecase  = False

# Tree-simplification while parsing:  none, flatten, merge_treetops, merge
@ reduction   = flatten         # anonymous nodes are being reduced where possible

# Tags that may be replaced with their content while parsing
@ disposable  = EOF, _number, _illegal

# Tags that will be dropped with all their content while parsing or any of
# the special values: strings, backticked, whitespace, regexps
# Here, EOF and insignificant whitespace (tilde) will be dropped
@ drop        = EOF, whitespace


#: Regular Expressions

regular_expression = [flagGroups] (regex | `)`) EOF
regex      = pattern { `|` pattern }
pattern    = { item [repetition] }
item       = entity  | allChars
entity     = special | escape | charset | group

flagGroups = { `(?` flags § `)` }+
flags      = /[aiLmsux]+/ [`-` /[imsx]+/]


#: repetition

repetition = repeater [ notGreedy | noBacktracking ]
  repeater = zeroOrOne | zeroOrMore | oneOrMore | range
    zeroOrOne  = `?`
    zeroOrMore = `*`
    oneOrMore  = `+`
    range      = `{` min [`,` max] `}`
      min      = _number
      max      = _number
      _number  = /[0-9]+/
  notGreedy      = `?`
  noBacktracking = `+`


#: special

special    = any | start | end
  any      = `.`
  start    = `^`
  end      = `$`

#: escape

escape       = BS ( reEsc | chEsc | chCode | chName | groupId | error | anyChar )
  reEsc      = /[AbBZ]/
  chEsc      = /[abdDfnrsStvwW\\]/
  chCode     = `x` hex*2 | `u` hex*4 | `U` hex*8 | octal
     hex     = /[0-9a-fA-F]/
     octal   = `0` oct{0,3} | oct*3
     oct     = /[0-7]/
  chName     = `N` § `{` /[\w ]+/ `}`
  groupId    = /\d\d?/
  groupName  = /(?!\d)\w+/
  error      = &_illegal @Error("Unknown escape sequence") _illegal
    _illegal = /[a-zA-Z]/

#: charset

charset    = `[` { chRange | escapedSet | escapedCh | ch }+ `]`
  chRange    = (escapedCh | ch) `-` (escapedCh | ch)
  escapedSet = BS /[dDsSwW]/
  escapedCh  = BS (chCode | /[abfnrtv\\]/)
  ch         = BS error | !`]` [BS] anyChar


#: group

group     = `(` § (extension | grpRegex) `)`
extension = `?` § ( nonCapturing | subRegex | namedGroup | backRef
                  | comment | lookaround | bifurcation)

nonCapturing = [flags] `:` § grpRegex
subRegex   = `>` § grpRegex
namedGroup = `P<` § groupName `>` grpRegex
backRef    = `P=` § groupName
comment    = `#` /(?:[\\]\)|[^)\\]+)+/

lookaround = lrtype § grpRegex
  lrtype   = `=` | `!` | `<=` | `<!`

bifurcation = `(` § (groupId | groupName) `)` pattern `|` grpPattern

grpRegex   = grpPattern { `|` grpPattern }
grpPattern = { grpItem [repetition] }
grpItem    = entity  | characters

#: misc

characters = { !entity character }+
character  = /[^)]/
allChars   = { !entity anyChar }+
anyChar    = /.|\n/

BS  = /\\/   # a single backslash
EOF = !/./