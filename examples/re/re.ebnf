# re-grammar

#######################################################################
#
#  EBNF-Directives
#
#######################################################################

# Regular expression for implicit whitespace or one of: horizontal, linefeed, vertical
# Implicit whitespace is denoted by the tilde-character: ~
@ whitespace  = //  # never match any whitespace, but match empty string
# @ whitespace  = /\s*(?:#.*(?=\n|$))?\s*/  # match whitespace and comments for verbose regular expressions!

# Implicit whitespace adjacent to literals: left, right, both, none
# E.g. if @literalws = right then ")" means the same as ")"~
@ literalws   = none

# Regular expression for comments, e.g. /#.*(?:\n|$)/
# Use: /(?:\/\/.*)|(?:\/\*(?:.|\n)*?\*\/)/ for C++-style comments: /* ... */ or // to EOL
@ comment     = //

# Case-sensitivity: True, False
@ ignorecase  = False

# Tree-simplification while parsing:  none, flatten, merge_treetops, merge
@ reduction   = merge         # anonymous nodes are being reduced where possible

# Tags that may be replaced with their content while parsing
@ disposable  = EOF, BS, _number, _illegal, _entity, _escape, _special, _item,
                _group, _grpItem, _extension, _char, _anyChar, _grpChar,
                _chars, _grpChars, _octal, _nibble, _escapedCh, _ch, _reEsc,
                _csEsc

# Tags that will be dropped with all their content while parsing or any of
# the special values: strings, backticked, whitespace, regexps
# Here, EOF and insignificant whitespace (tilde) will be dropped
@ drop        = EOF, BS, whitespace, strings


#: Regular Expressions

regular_expression = [flagGroups] (alternative| ")") EOF
alternative = sequence { "|" sequence }
sequence    = { repetition | _item }
_item       = (_entity | _chars)
_entity     = _special | _escape | charset | _group

flagGroups  = { "(?" flags § ")" }+
flags       =  positive [negative] | negative
  positive  = /[aiLmsux]+/
  negative  = "-" /[imsx]+/


#: repetition

repetition       = _item repType [ notGreedy | noBacktracking ]
  repType        = zeroOrOne | zeroOrMore | oneOrMore | range
    zeroOrOne    = "?"
    zeroOrMore   = "*"
    oneOrMore    = "+"
    range        = "{" min ["," max] "}"
      min        = _number
      max        = _number
      _number    = /[0-9]+/
  notGreedy      = "?"
  noBacktracking = "+"


#: special

_special = any | start | end
  any    = "."
  start  = "^"
  end    = "$"

#: escape

_escape      = BS § ( bs | chCode | chName | groupRef | _reEsc | specialEsc | error | escCh )
  _reEsc     = &/[AbBdDsSwWZ]/ (fixedChSet | wordBorder | absStart | absEnd)
  specialEsc = /[afnrtv]/
  chCode     = "x" hex2 | "u" hex4 | "U" hex8 | oct
    hex2     = _nibble*2
    hex4     = _nibble*4
    hex8     = _nibble*8
    _nibble  = /[0-9a-fA-F]/
    oct      = "0" _octal{0,3} | _octal*3
    _octal   = /[0-7]/
  chName     = "N{" /[\w ]+/ "}"
  escCh      = _anyChar | /[)|+*?]/
  groupRef   = /\d\d?/
  error      = &_illegal @Error("Unknown escape sequence") _illegal
    _illegal = /[a-zA-Z]/

wordBorder   = /[bB]/
absStart     = /[aA]/
absEnd       = /[zZ]/


#: charset

# What about https://unicode.org/reports/tr18/ ?

charset      = "[" [complement] { _csEsc | chRange | _escapedCh | BS error | chSet }+ "]"
  complement = "^"
  chRange    = (_escapedCh | ch) "-" !_csEsc (_escapedCh | ch)
  chSet      = _ch  { !_csEsc !chRange !_escapedCh !BS _ch }
  _csEsc     = BS fixedChSet
  _escapedCh = BS (chCode | chSpecial)
  chSpecial  = /[abfnrtv]/  # /b means backspace inside character ranges
  ch         = _ch
  _ch        = !"]" [BS] /./

fixedChSet   = /[dDsSwW]/  # /lL/ for letters only occurs later in the pipeline

#: group

_group         = "(" § (_extension | capturing) ")"
_extension     = "?" § ( nonCapturing | subRegex | namedGroup | backRef
                       | comment | lookaround | bifurcation)

capturing      = grpAlternative
nonCapturing   = [flags] ":" § grpAlternative
subRegex       = ">" § grpAlternative
namedGroup     = "P<" § groupName ">" grpAlternative
backRef        = "P=" § groupName
comment        = "#" /(?:[\\]\)|[^)\\]+)+/

lookaround     = lrtype § grpAlternative
  lrtype       = `=` | `!` | `<=` | `<!`

bifurcation    = "(" § (groupId | groupName) ")" sequence "|" grpSequence
  groupId      = /\d\d?/
groupName      = /(?!\d)\w+/

grpAlternative = grpSequence { "|" grpSequence }
grpSequence    = { grpRepetition | _grpItem }
grpRepetition  = _grpItem repType [ notGreedy | noBacktracking ]
_grpItem       = (_entity  | _grpChars)

#: misc

_chars     = char | charSeq
_grpChars  = grpChar | grpCharSeq

grpCharSeq = _grpChar { _grpChar }+
grpChar    = _grpChar !_grpChar
_grpChar   = !_entity /[^)|+*?]/

charSeq    = _char { _char }+
char       = _char !_char
_char      = !_entity _anyChar
_anyChar   = /[^|+*?]/

BS  = bs
bs  = /\\/   # a single backslash
EOF = !/./

# VERBOSE_WHITESPACE = /\s*(?:#.*(?=\n|$))?\s*/  # whitespace (including comments) in verbose mode
