LOG-FILE: logs/EBNFServer_20d2c7ebe50.log

Python Version: 3.8.1 (tags/v3.8.1:1b293b6, Dec 18 2019, 23:11:46) [MSC v.1916 64 bit (AMD64)]
DHParser Version: 0.9.3


LOOP: <ProactorEventLoop running=True closed=False debug=False>

SERVER MESSAGE: New connection: 2255613743504
RECEIVE (2533, 2509, 24): Content-Length: 2509
{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":17400,"rootPath":"c:\\Users\\di68kap\\PycharmProjects\\DHParser\\examples\\EBNF_fork","rootUri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"]}},"definition":{"dynamicRegistration":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true},"documentLink":{"dynamicRegistration":true},"typeDefinition":{"dynamicRegistration":true},"implementation":{"dynamicRegistration":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true}}},"trace":"off","workspaceFolders":[{"uri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork","name":"EBNF_fork"}]}}

RESPONSE: Content-Length: 215
{"jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 2, "completionProvider": {"resolveProvider": false, "triggerCharacters": ["@"]}}, "serverInfo": {"name": "EBNF-Server", "version": "0.2"}}, "id": 0}

RECEIVE (74, 52, 22): Content-Length: 52
{"jsonrpc":"2.0","method":"initialized","params":{}}

RECEIVE (7250, 7226, 24): Content-Length: 7226
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf","languageId":"ebnf","version":1,"text":"# EBNF-Grammar in EBNF\n\n# This grammar is tuned for flexibility, that is, it supports as many\n# different flavors of EBNF as possible. However, this flexibility\n# comes at the cost of some ambiguities. In particular:\n#\n#    1. the alternative OR-operator / could be mistaken for the start\n#       of a regular expression and vice versa, and\n#    2. character ranges [a-z] can be mistaken for optional blocks\n#       and vice versa\n#\n# A strategy to avoid these ambiguities is to do all of the following:\n#\n#     - replace the free_char-parser by a never matching parser\n#     - if this is done, it is safe to replace the char_range_heuristics-\n#       parser by an always matching parser\n#     - replace the regex_heuristics by an always matching parser\n#\n# Ambiguities can also be avoided by NOT using all the syntactic variants\n# made possible by this EBNF-grammar within one and the same EBNF-document\n\n@ comment    = /(?!#x[A-Fa-f0-9])#.*(?:\\n|$)|\\/\\*(?:.|\\n)*?\\*\\/|\\(\\*(?:.|\\n)*?\\*\\)/\n    # comments can be either C-Style: /* ... */\n    # or pascal/modula/oberon-style: (* ... *)\n    # or python-style: # ... \\n, excluding, however, character markers: #x20\n@ whitespace = /\\s*/                            # whitespace includes linefeed\n@ literalws  = right                            # trailing whitespace of literals will be ignored tacitly\n@ anonymous  = pure_elem, countable, FOLLOW_UP, SYM_REGEX, ANY_SUFFIX, EOF\n@ drop       = whitespace, EOF                  # do not include these even in the concrete syntax tree\n@ RNG_BRACE_filter = matching_bracket()         # filter or transform content of RNG_BRACE on retrieve\n\n# re-entry-rules for resuming after parsing-error\n\n@ definition_resume = /\\n\\s*(?=@|\\w+\\w*\\s*=)/\n@ directive_resume  = /\\n\\s*(?=@|\\w+\\w*\\s*=)/\n\n\n# specialized error messages for certain cases\n\n@ definition_error  = /,/, 'Delimiter \",\" not expected in definition!\\nEither this was meant to '\n                           'be a directive and the directive symbol @ is missing\\nor the error is '\n                           'due to inconsistent use of the comma as a delimiter\\nfor the elements '\n                           'of a sequence.'\n\n\n#: top-level\n\nsyntax     = ~ { definition | directive } EOF\ndefinition = symbol §:DEF~ [ :OR~ ] expression :ENDL~ & FOLLOW_UP  # [:OR~] to support v. Rossum's syntax\n\ndirective  = \"@\" §symbol \"=\" (regexp | literals | procedure | symbol !DEF)\n             { \",\" (regexp | literals | procedure | symbol !DEF) } & FOLLOW_UP\nliterals   = { literal }+                       # string chaining, only allowed in directives!\nprocedure  = SYM_REGEX \"()\"                     # procedure name, only allowed in directives!\n\nFOLLOW_UP  = `@` | symbol | EOF\n\n\n#: components\n\nexpression = sequence { :OR~ sequence }\nsequence   = [\"§\"] ( interleave | lookaround )  # \"§\" means all following terms mandatory\n             { :AND~ [\"§\"] ( interleave | lookaround ) }\ninterleave = difference { \"°\" [\"§\"] difference }\nlookaround = flowmarker § (oneormore | pure_elem)\ndifference = term [\"-\" § (oneormore | pure_elem)]\nterm       = oneormore | counted | repetition | option | pure_elem\n\n\n#: elements\n\ncountable  = option | oneormore | element\npure_elem  = element § !ANY_SUFFIX              # element strictly without a suffix\nelement    = [retrieveop] symbol !:DEF          # negative lookahead to be sure it's not a definition\n           | literal\n           | plaintext\n           | regexp\n           | char_range\n           | character ~\n           | any_char\n           | whitespace\n           | group\n\n\nANY_SUFFIX = /[?*+]/\n\n\n#: flow-operators\n\nflowmarker = \"!\"  | \"&\"                         # '!' negative lookahead, '&' positive lookahead\n           | \"<-!\" | \"<-&\"                      # '<-!' negative lookbehind, '<-&' positive lookbehind\nretrieveop = \"::\" | \":?\" | \":\"                  # '::' pop, ':?' optional pop, ':' retrieve\n\n\n#: groups\n\ngroup      = \"(\" no_range §expression \")\"\noneormore  = \"{\" no_range expression \"}+\" | element \"+\"\nrepetition = \"{\" no_range §expression \"}\" | element \"*\" no_range\noption     = !char_range \"[\" §expression \"]\" | element \"?\"\ncounted    = countable range | countable :TIMES~ multiplier | multiplier :TIMES~ §countable\n\nrange      = RNG_BRACE~ multiplier [ :RNG_DELIM~ multiplier ] ::RNG_BRACE~\nno_range   = !multiplier | &multiplier :TIMES\nmultiplier = /[1-9]\\d*/~\n\n\n#: leaf-elements\n\nsymbol     = SYM_REGEX ~                        # e.g. expression, term, parameter_list\nliteral    = /\"(?:(?<!\\\\)\\\\\"|[^\"])*?\"/~         # e.g. \"(\", '+', 'while'\n           | /'(?:(?<!\\\\)\\\\'|[^'])*?'/~         # whitespace following literals will be ignored tacitly.\nplaintext  = /`(?:(?<!\\\\)\\\\`|[^`])*?`/~         # like literal but does not eat whitespace\n           | /´(?:(?<!\\\\)\\\\´|[^´])*?´/~\nregexp     = :RE_LEADIN RE_CORE :RE_LEADOUT ~   # e.g. /\\w+/, ~/#.*(?:\\n|$)/~\n# regexp     = /\\/(?:(?<!\\\\)\\\\(?:\\/)|[^\\/])*?\\//~     # e.g. /\\w+/, ~/#.*(?:\\n|$)/~\nchar_range = `[` &char_range_heuristics\n                 [`^`] (character | free_char) { [`-`] character | free_char } \"]\"\ncharacter  = :CH_LEADIN HEXCODE\nfree_char  = /[^\\n\\[\\]\\\\]/ | /\\\\[nrt`´'\"(){}\\[\\]\\/\\\\]/\nany_char   = \".\"\nwhitespace = /~/~                               # insignificant whitespace\n\n#: delimiters\n\nEOF = !/./ [:?DEF] [:?OR] [:?AND] [:?ENDL]      # [:?DEF], [:?OR], ... clear stack by eating stored value\n           [:?RNG_DELIM] [:?BRACE_SIGN] [:?CH_LEADIN] [:?TIMES] [:?RE_LEADIN] [:?RE_LEADOUT]\n\nDEF        = `=` | `:=` | `::=` | `<-` | /:\\n/ | `: `  # with `: `, retrieve markers mustn't be followed by a blank!\nOR         = `|` | `/` !regex_heuristics\nAND        = `,` | ``\nENDL       = `;` | ``\n\nRNG_BRACE  = :BRACE_SIGN\nBRACE_SIGN = `{` | `(`\nRNG_DELIM  = `,`\nTIMES      = `*`\n\nRE_LEADIN  = `/` &regex_heuristics | `^/`\nRE_LEADOUT = `/`\n\nCH_LEADIN  = `0x` | `#x`\n\n#: heuristics\n\nchar_range_heuristics  = ! ( /[\\n\\t ]/\n                           | ~ literal_heuristics\n                           | [`::`|`:?`|`:`] SYM_REGEX /\\s*\\]/ )\nliteral_heuristics     = /~?\\s*\"(?:[\\\\]\\]|[^\\]]|[^\\\\]\\[[^\"]*)*\"/\n                       | /~?\\s*'(?:[\\\\]\\]|[^\\]]|[^\\\\]\\[[^']*)*'/\n                       | /~?\\s*`(?:[\\\\]\\]|[^\\]]|[^\\\\]\\[[^`]*)*`/\n                       | /~?\\s*´(?:[\\\\]\\]|[^\\]]|[^\\\\]\\[[^´]*)*´/\n                       | /~?\\s*\\/(?:[\\\\]\\]|[^\\]]|[^\\\\]\\[[^\\/]*)*\\//\nregex_heuristics       = /[^ ]/ | /[^\\/\\n*?+\\\\]*[*?+\\\\][^\\/\\n]\\//\n\n\n#: basic-regexes\n\nRE_CORE    = /(?:(?<!\\\\)\\\\(?:\\/)|[^\\/])*/       # core of a regular expression, i.e. the dots in /.../\nSYM_REGEX  = /(?!\\d)\\w+/                        # regular expression for symbols\nHEXCODE    = /[A-Fa-f0-9]{1,8}/\n\n"}}}

compile_text 1: file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf
compile_text 2
RECEIVE (327, 304, 23): Content-Length: 304
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf","version":2},"contentChanges":[{"range":{"start":{"line":20,"character":0},"end":{"line":20,"character":0}},"rangeLength":0,"text":"@"}]}}

RECEIVE (287, 264, 23): Content-Length: 264
{"jsonrpc":"2.0","id":1,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf"},"position":{"line":20,"character":1},"context":{"triggerKind":2,"triggerCharacter":"@"}}}

RESPONSE: Content-Length: 41
{"jsonrpc": "2.0", "result": {}, "id": 1}

compile_text 1: file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf
compile_text 2
compile_text 3: None
compile_text 4

CALL: {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"uri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf","version":2,"diagnostics":[]}}

compile_text 3: None
compile_text 4

CALL: {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"uri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf","version":2,"diagnostics":[{"range":{"start":{"line":20,"character":0},"end":{"line":20,"character":1}},"severity":1,"code":1000,"source":"DHParser","message":"Unknown directive \n ! (Known directives: comment, whitespace, literalws, ignorecase, [preprocessor_]tokens, anonymous, drop, $SYMBOL_filer, $SYMBOL_error, $SYMBOL_skip, $SYMBOL_resume.)"},{"range":{"start":{"line":21,"character":0},"end":{"line":21,"character":1}},"severity":1,"code":1010,"source":"DHParser","message":"symbol expected, \u00bb@ comment ...\u00ab found!"}]}}

RECEIVE (201, 178, 23): Content-Length: 178
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf","version":2}}}

RECEIVE (326, 303, 23): Content-Length: 303
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf","version":3},"contentChanges":[{"range":{"start":{"line":20,"character":0},"end":{"line":20,"character":1}},"rangeLength":1,"text":""}]}}

compile_text 1: file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf
compile_text 2
compile_text 3: None
compile_text 4

CALL: {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"uri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf","version":3,"diagnostics":[]}}

RECEIVE (201, 178, 23): Content-Length: 178
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///c%3A/Users/di68kap/PycharmProjects/DHParser/examples/EBNF_fork/EBNF.ebnf","version":3}}}

RECEIVE (80, 58, 22): Content-Length: 58
{"jsonrpc":"2.0","id":2,"method":"shutdown","params":null}

RESPONSE: Content-Length: 41
{"jsonrpc": "2.0", "result": {}, "id": 2}

RECEIVE (69, 47, 22): Content-Length: 47
{"jsonrpc":"2.0","method":"exit","params":null}

SERVER MESSAGE: Closing connection: 2255613743504.

