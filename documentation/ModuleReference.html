

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Module Reference &mdash; DHParser 0.8 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="DHParser 0.8 documentation" href="index.html"/>
        <link rel="prev" title="DHParser Reference Manual" href="ReferenceManual.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> DHParser
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="UserGuide.html">DHParser User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="ReferenceManual.html">DHParser Reference Manual</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Module Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#main-modules-reference">Main Modules Reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-preprocess">Module <code class="docutils literal notranslate"><span class="pre">preprocess</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-syntaxtree">Module <code class="docutils literal notranslate"><span class="pre">syntaxtree</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-parse">Module <code class="docutils literal notranslate"><span class="pre">parse</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-transform">Module <code class="docutils literal notranslate"><span class="pre">transform</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-compile">Module <code class="docutils literal notranslate"><span class="pre">compile</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-error">Module <code class="docutils literal notranslate"><span class="pre">error</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#domain-specific-language-modules-reference">Domain Specific Language Modules Reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-ebnf">Module <code class="docutils literal notranslate"><span class="pre">ebnf</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-dsl">Module <code class="docutils literal notranslate"><span class="pre">dsl</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-testing">Module <code class="docutils literal notranslate"><span class="pre">testing</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#supporting-modules-reference">Supporting Modules Reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-toolkit">Module <code class="docutils literal notranslate"><span class="pre">toolkit</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-log">Module <code class="docutils literal notranslate"><span class="pre">log</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-stringview">Module <code class="docutils literal notranslate"><span class="pre">stringview</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-versionnumber">Module <code class="docutils literal notranslate"><span class="pre">versionnumber</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">DHParser</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Module Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/ModuleReference.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-reference">
<h1>Module Reference<a class="headerlink" href="#module-reference" title="Permalink to this headline">¶</a></h1>
<p>DHParser is split into a number of modules plus one command line utility
(<code class="docutils literal notranslate"><span class="pre">dhparser.py</span></code>, which will not be described here.)</p>
<p>Usually, the user or “importer” of DHParser does not need to worry
about its internal module structure, because DHParser provides a flat
namespace form which all of its symbols can be imported, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">DHParser</span> <span class="k">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">DHParser</span> <span class="k">import</span> <span class="n">recompile_grammar</span><span class="p">,</span> <span class="n">grammar_suite</span><span class="p">,</span> <span class="n">compile_source</span>
</pre></div>
</div>
<p>However, in order to add or change the source code of DHParser, its module
structure must be understood. DHParser’s modules can roughly be sorted into
three different categories:</p>
<ol class="arabic simple">
<li>Modules that contain the basic funcionality for packrat-parsing,
AST-transformation and the skeleton for a DSL-compilers.</li>
<li>Modules for EBNF-Grammars and DSL compilation.</li>
<li>Support or “toolkit”-modules that contain different helpful functions</li>
</ol>
<p>The import-order of DHParser’s modules runs accross these categories. In the
following list the modules further below in the list may import one or
more of the modules further above in the list, but not the other way round:</p>
<ul class="simple">
<li>versionnumber.py – contains the verison number of DHParser</li>
<li>toolkit.py – utility functions for DHParser</li>
<li>stringview.py – a string class where slices are views not copies as
with the standard Python strings.</li>
<li>preprocess.py – preprocessing of source files for DHParser</li>
<li>error.py – error handling for DHParser</li>
<li>syntaxtree.py – syntax tree classes for DHParser</li>
<li><dl class="first docutils">
<dt>transform.py – transformation functions for converting the concrete</dt>
<dd>into the abstract syntax tree</dd>
</dl>
</li>
<li>logging.py – logging and debugging for DHParser</li>
<li>parse.py – parser combinators for for DHParser</li>
<li><dl class="first docutils">
<dt>compile.py – abstract base class for compilers that transform an AST</dt>
<dd>into something useful</dd>
</dl>
</li>
<li>ebnf.py – EBNF -&gt; Python-Parser compilation for DHParser</li>
<li>dsl.py – Support for domain specific notations for DHParser</li>
<li>testing.py – test support for DHParser based grammars and compilers</li>
</ul>
<div class="section" id="main-modules-reference">
<h2>Main Modules Reference<a class="headerlink" href="#main-modules-reference" title="Permalink to this headline">¶</a></h2>
<p>The core of DHParser are the modules containing the functionality
for the parsing and compiling process. The modules <code class="docutils literal notranslate"><span class="pre">preprocess</span></code>,
<code class="docutils literal notranslate"><span class="pre">parse</span></code>, <code class="docutils literal notranslate"><span class="pre">transform</span></code> and <code class="docutils literal notranslate"><span class="pre">compile</span></code> represent particular stages of the
parsing/compiling process, while <code class="docutils literal notranslate"><span class="pre">syntaxtree</span></code> and <code class="docutils literal notranslate"><span class="pre">error</span></code> define
classes for syntax trees and parser/compiler errors, respectively.</p>
<div class="section" id="module-preprocess">
<span id="module-preprocess"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">preprocess</span></code><a class="headerlink" href="#module-preprocess" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">preprocess</span></code> contains functions for preprocessing source
code before the parsing stage as well as source mapping facilities
to map the locations of parser and compiler errors to the
non-preprocessed source text.</p>
<p>Preprocessing (and source mapping of errors) will only be needed
for some domain specific languages, most notable those that
cannot completely be described with context-free grammars.</p>
<dl class="function">
<dt id="preprocess.make_token">
<code class="descname">make_token</code><span class="sig-paren">(</span><em>token: str</em>, <em>argument: str = ''</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/preprocess.html#make_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#preprocess.make_token" title="Permalink to this definition">¶</a></dt>
<dd><p>Turns the <code class="docutils literal notranslate"><span class="pre">token</span></code> and <code class="docutils literal notranslate"><span class="pre">argument</span></code> into a special token that
will be caught by the <code class="docutils literal notranslate"><span class="pre">PreprocessorToken</span></code>-parser.</p>
<p>This function is a support function that should be used by
preprocessors to inject preprocessor tokens into the source text.</p>
</dd></dl>

<dl class="function">
<dt id="preprocess.strip_tokens">
<code class="descname">strip_tokens</code><span class="sig-paren">(</span><em>tokenized: str</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/preprocess.html#strip_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#preprocess.strip_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces all tokens with the token’s arguments.</p>
</dd></dl>

<dl class="function">
<dt id="preprocess.nil_preprocessor">
<code class="descname">nil_preprocessor</code><span class="sig-paren">(</span><em>text: str</em><span class="sig-paren">)</span> &#x2192; Tuple[str, Union[typing.Callable[[int], int], functools.partial]]<a class="reference internal" href="_modules/preprocess.html#nil_preprocessor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#preprocess.nil_preprocessor" title="Permalink to this definition">¶</a></dt>
<dd><p>A preprocessor that does nothing, i.e. just returns the input.</p>
</dd></dl>

<dl class="function">
<dt id="preprocess.chain_preprocessors">
<code class="descname">chain_preprocessors</code><span class="sig-paren">(</span><em>*preprocessors</em><span class="sig-paren">)</span> &#x2192; Union[typing.Callable[[str], typing.Union[str, typing.Tuple[str, typing.Union[typing.Callable[[int], int], functools.partial]]]], functools.partial]<a class="reference internal" href="_modules/preprocess.html#chain_preprocessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#preprocess.chain_preprocessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges a seuqence of preprocessor functions in to a single function.</p>
</dd></dl>

<dl class="function">
<dt id="preprocess.prettyprint_tokenized">
<code class="descname">prettyprint_tokenized</code><span class="sig-paren">(</span><em>tokenized: str</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/preprocess.html#prettyprint_tokenized"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#preprocess.prettyprint_tokenized" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pretty-printable version of a document that contains tokens.</p>
</dd></dl>

<dl class="class">
<dt id="preprocess.SourceMap">
<em class="property">class </em><code class="descname">SourceMap</code><span class="sig-paren">(</span><em>positions</em>, <em>offsets</em><span class="sig-paren">)</span><a class="headerlink" href="#preprocess.SourceMap" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="preprocess.SourceMap.offsets">
<code class="descname">offsets</code><a class="headerlink" href="#preprocess.SourceMap.offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="preprocess.SourceMap.positions">
<code class="descname">positions</code><a class="headerlink" href="#preprocess.SourceMap.positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="preprocess.tokenized_to_original_mapping">
<code class="descname">tokenized_to_original_mapping</code><span class="sig-paren">(</span><em>tokenized_source: str</em><span class="sig-paren">)</span> &#x2192; preprocess.SourceMap<a class="reference internal" href="_modules/preprocess.html#tokenized_to_original_mapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#preprocess.tokenized_to_original_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a source map for mapping positions in a text that has
been enriched with token markers to their original positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tokenized_source</strong> – the source text enriched with token markers</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a source map, i.e. a list of positions and a list of corresponding
offsets. The list of positions is ordered from smallest to highest.
An offset is valid for its associated position and all following
positions until (and excluding) the next position in the list of
positions.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="preprocess.source_map">
<code class="descname">source_map</code><span class="sig-paren">(</span><em>position: int</em>, <em>srcmap: preprocess.SourceMap</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/preprocess.html#source_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#preprocess.source_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps a position in a (pre-)processed text to its corresponding
position in the original document according to the given source map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>position</strong> – the position in the processed text</li>
<li><strong>srcmap</strong> – the source map, i.e. a mapping of locations to offset values</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the mapped position</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="preprocess.with_source_mapping">
<code class="descname">with_source_mapping</code><span class="sig-paren">(</span><em>result: Union[str, typing.Tuple[str, typing.Union[typing.Callable[[int], int], functools.partial]]]</em><span class="sig-paren">)</span> &#x2192; Tuple[str, Union[typing.Callable[[int], int], functools.partial]]<a class="reference internal" href="_modules/preprocess.html#with_source_mapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#preprocess.with_source_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes preprocessors results, by adding a mapping if a preprocessor
only returns the transformed source code and no mapping by itself. It is
assumed that in this case the preprocessor has just enriched the source
code with tokens, so that a source mapping can be derived automatically
with <a class="reference internal" href="#preprocess.tokenized_to_original_mapping" title="preprocess.tokenized_to_original_mapping"><code class="xref py py-func docutils literal notranslate"><span class="pre">tokenized_to_original_mapping()</span></code></a> (see above).</p>
</dd></dl>

</div>
<div class="section" id="module-syntaxtree">
<span id="module-syntaxtree"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">syntaxtree</span></code><a class="headerlink" href="#module-syntaxtree" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">syntaxtree</span></code> defines the <code class="docutils literal notranslate"><span class="pre">Node</span></code>-class for syntax trees as well
as an abstract base class for parser-objects. The latter is defined
here, because node-objects refer to parser-objects. All concrete
parser classes are defined in the <code class="docutils literal notranslate"><span class="pre">parse</span></code> module.</p>
<dl class="class">
<dt id="syntaxtree.ParserBase">
<em class="property">class </em><code class="descname">ParserBase</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/syntaxtree.html#ParserBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.ParserBase" title="Permalink to this definition">¶</a></dt>
<dd><p>ParserBase is the base class for all real and mock parser classes.
It is defined here, because Node objects require a parser object
for instantiation.</p>
<dl class="method">
<dt id="syntaxtree.ParserBase.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>func: Callable</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/syntaxtree.html#ParserBase.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.ParserBase.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the function <cite>func</cite> to the parser. Returns False, if
- for whatever reason - the functions has not been applied, True
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.ParserBase.grammar">
<code class="descname">grammar</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; object<a class="reference internal" href="_modules/syntaxtree.html#ParserBase.grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.ParserBase.grammar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Grammar object to which the parser belongs. If not
yet connected to any Grammar object, None is returned.</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.ParserBase.name">
<code class="descname">name</code><a class="headerlink" href="#syntaxtree.ParserBase.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the parser or the empty string ‘’ for unnamed
parsers.</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.ParserBase.ptype">
<code class="descname">ptype</code><a class="headerlink" href="#syntaxtree.ParserBase.ptype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of the parser. By default this is the parser’s
class name preceded by a colon, e.g. ‘:ZeroOrMore’.</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.ParserBase.repr">
<code class="descname">repr</code><a class="headerlink" href="#syntaxtree.ParserBase.repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the parser’s name if it has a name and repr()</p>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.ParserBase.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/syntaxtree.html#ParserBase.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.ParserBase.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets any parser variables. (Should be overridden.)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="syntaxtree.MockParser">
<em class="property">class </em><code class="descname">MockParser</code><span class="sig-paren">(</span><em>name=''</em>, <em>ptype=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/syntaxtree.html#MockParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.MockParser" title="Permalink to this definition">¶</a></dt>
<dd><p>MockParser objects can be used to reconstruct syntax trees from a
serialized form like S-expressions or XML. Mock objects can mimic
different parser types by assigning them a ptype on initialization.</p>
<p>Mock objects should not be used for anything other than
syntax tree (re-)construction. In all other cases where a parser
object substitute is needed, chose the singleton ZOMBIE_PARSER.</p>
</dd></dl>

<dl class="class">
<dt id="syntaxtree.ZombieParser">
<em class="property">class </em><code class="descname">ZombieParser</code><a class="reference internal" href="_modules/syntaxtree.html#ZombieParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.ZombieParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Serves as a substitute for a Parser instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">ZombieParser</span></code> is the class of the singelton object
<code class="docutils literal notranslate"><span class="pre">ZOMBIE_PARSER</span></code>. The  <code class="docutils literal notranslate"><span class="pre">ZOMBIE_PARSER</span></code> has a name and can be
called, but it never matches. It serves as a substitute where only
these (or one of these properties) is needed, but no real Parser-
object is instantiated.</p>
</dd></dl>

<dl class="class">
<dt id="syntaxtree.Node">
<em class="property">class </em><code class="descname">Node</code><span class="sig-paren">(</span><em>parser, result: Union[typing.Tuple[_ForwardRef('Node'), ...], _ForwardRef('Node'), DHParser.stringview.StringView, str, NoneType], leafhint: bool = False</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/syntaxtree.html#Node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a node in the concrete or abstract syntax tree.</p>
<dl class="attribute">
<dt id="syntaxtree.Node.tag_name">
<code class="descname">tag_name</code><a class="headerlink" href="#syntaxtree.Node.tag_name" title="Permalink to this definition">¶</a></dt>
<dd><p><em>str</em> – The name of the node, which is either its
parser’s name or, if that is empty, the parser’s class name</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node.result">
<code class="descname">result</code><a class="headerlink" href="#syntaxtree.Node.result" title="Permalink to this definition">¶</a></dt>
<dd><p><em>str or tuple</em> – The result of the parser which
generated this node, which can be either a string or a
tuple of child nodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node.children">
<code class="descname">children</code><a class="headerlink" href="#syntaxtree.Node.children" title="Permalink to this definition">¶</a></dt>
<dd><p><em>tuple</em> – The tuple of child nodes or an empty tuple
if there are no child nodes. READ ONLY!</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node.content">
<code class="descname">content</code><a class="headerlink" href="#syntaxtree.Node.content" title="Permalink to this definition">¶</a></dt>
<dd><p><em>str</em> – Yields the contents of the tree as string. The
difference to <code class="docutils literal notranslate"><span class="pre">str(node)</span></code> is that <code class="docutils literal notranslate"><span class="pre">node.content</span></code> does
not add the error messages to the returned string.</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node.parser">
<code class="descname">parser</code><a class="headerlink" href="#syntaxtree.Node.parser" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Parser</em> – The parser which generated this node.
WARNING: In case you use mock syntax trees for testing or
parser replacement during the AST-transformation: DO NOT
rely on this being a real parser object in any phase after
parsing (i.e. AST-transformation and compiling), for
example by calling <code class="docutils literal notranslate"><span class="pre">isinstance(node.parer,</span> <span class="pre">...)</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node.errors">
<code class="descname">errors</code><a class="headerlink" href="#syntaxtree.Node.errors" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> – A list of parser- or compiler-errors:
tuple(position, string) attached to this node</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node.error_flag">
<code class="descname">error_flag</code><a class="headerlink" href="#syntaxtree.Node.error_flag" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int</em> – 0 if no error occurred in either the node
itself or any of its descendants. Otherwise contains the
highest warning or error level or all errors that occurred.</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node.len">
<code class="descname">len</code><a class="headerlink" href="#syntaxtree.Node.len" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int</em> – The full length of the node’s string result if the
node is a leaf node or, otherwise, the concatenated string
result’s of its descendants. The figure always represents
the length before AST-transformation and will never change
through AST-transformation. READ ONLY!</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node.pos">
<code class="descname">pos</code><a class="headerlink" href="#syntaxtree.Node.pos" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int</em> – the position of the node within the parsed text.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">pos</span></code> is -1 meaning invalid by default.
Setting this value will set the positions of all child
nodes relative to this value.</p>
<p>To set the pos values of all nodes in a syntax tree, the
pos value of the root node should be set to 0 right
after parsing.</p>
<p>Other than that, this value should be considered READ ONLY.
At any rate, it should only be reassigned during the parsing
stage and never during or after the AST-transformation.</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node.attributes">
<code class="descname">attributes</code><a class="headerlink" href="#syntaxtree.Node.attributes" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict</em> – An optional dictionary of XML-attributes. This
dictionary is created lazily upon first usage. The attributes
will only be shown in the XML-Representation, not in the
S-Expression-output.</p>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node._parent">
<code class="descname">_parent</code><a class="headerlink" href="#syntaxtree.Node._parent" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Node</em> – SLOT RESERVED FOR FUTURE USE!</p>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.Node.add_error">
<code class="descname">add_error</code><span class="sig-paren">(</span><em>message: str</em>, <em>code: int = 1000</em><span class="sig-paren">)</span> &#x2192; syntaxtree.Node<a class="reference internal" href="_modules/syntaxtree.html#Node.add_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.Node.add_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an error to this Node.
:param message: A string with the error message.abs
:type message: str
:param code: An error code to identify the kind of error
:type code: int</p>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.Node.as_sxpr">
<code class="descname">as_sxpr</code><span class="sig-paren">(</span><em>src: str = None</em>, <em>compact: bool = False</em>, <em>showerrors: bool = True</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/syntaxtree.html#Node.as_sxpr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.Node.as_sxpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns content as S-expression, i.e. in lisp-like form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> – The source text or <cite>None</cite>. In case the source text is
given the position of the element in the text will be
reported as line and column.</li>
<li><strong>compact</strong> – If True a compact representation is returned where
brackets are omitted and only the indentation indicates the
tree structure.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.Node.as_xml">
<code class="descname">as_xml</code><span class="sig-paren">(</span><em>src: str = None</em>, <em>showerrors: bool = True</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/syntaxtree.html#Node.as_xml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.Node.as_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns content as XML-tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src</strong> – The source text or <cite>None</cite>. In case the source text is
given the position will also be reported as line and
column.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">attributes</code></dt>
<dd><p>Returns a dictionary of XML-Attributes attached to the Node.</p>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.Node.collect_errors">
<code class="descname">collect_errors</code><span class="sig-paren">(</span><em>clear_errors=False</em><span class="sig-paren">)</span> &#x2192; List[DHParser.error.Error]<a class="reference internal" href="_modules/syntaxtree.html#Node.collect_errors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.Node.collect_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively adds line- and column-numbers to all error objects.
Returns all errors of this node or any child node in the form
of a set of tuples (position, error_message), where position
is always relative to this node.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">content</code></dt>
<dd><p>Returns content as string, omitting error messages.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">errors</code></dt>
<dd><p>Returns the errors that occurred at this Node,
not including any errors from child nodes.</p>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.Node.init_pos">
<code class="descname">init_pos</code><span class="sig-paren">(</span><em>pos: int</em>, <em>overwrite: bool = False</em><span class="sig-paren">)</span> &#x2192; syntaxtree.Node<a class="reference internal" href="_modules/syntaxtree.html#Node.init_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.Node.init_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>(Re-)initialize position value. Usually, the parser guard
(<cite>parsers.add_parser_guard()</cite>) takes care of assigning the
position in the document to newly created nodes. However,
where Nodes are created outside the reach of the parser
guard, their document-position must be assigned manually.
This function recursively reassigns the position values
of the child nodes, too.</p>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.Node.pick">
<code class="descname">pick</code><span class="sig-paren">(</span><em>tag_names: Union[str, typing.Set[str]]</em><span class="sig-paren">)</span> &#x2192; Union[_ForwardRef('Node'), NoneType]<a class="reference internal" href="_modules/syntaxtree.html#Node.pick"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.Node.pick" title="Permalink to this definition">¶</a></dt>
<dd><p>Picks the first descendant with one of the given tag_names.</p>
<p>This function is just syntactic sugar for
<code class="docutils literal notranslate"><span class="pre">next(node.select_by_tag(tag_names,</span> <span class="pre">False))</span></code>. However, rather than
raising a StopIterationError if no descendant with the given tag-name
exists, it returns None.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">pos</code></dt>
<dd><p>Returns the position of the Node’s content in the source text.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">result</code></dt>
<dd><p>Returns the result from the parser that created the node.
Error messages are not included in the result. Use <cite>self.content()</cite>
if the result plus any error messages is needed.</p>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.Node.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>match_function: Callable</em>, <em>include_root: bool = True</em><span class="sig-paren">)</span> &#x2192; Iterator[_ForwardRef('Node')]<a class="reference internal" href="_modules/syntaxtree.html#Node.select"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.Node.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds nodes in the tree that fulfill a given criterion.</p>
<p><cite>select</cite> is a generator that yields all nodes for which the
given <cite>match_function</cite> evaluates to True. The tree is
traversed pre-order.</p>
<p>See function <cite>Node.select_by_tag</cite> for some examples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>match_function</strong> (<em>function</em>) – A function  that takes as Node
object as argument and returns True or False</li>
<li><strong>include_root</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a>) – If False, only descendant nodes will be
checked for a match.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last"><em>Node</em> – All nodes of the tree for which
<code class="docutils literal notranslate"><span class="pre">match_function(node)</span></code> returns True</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.Node.select_by_tag">
<code class="descname">select_by_tag</code><span class="sig-paren">(</span><em>tag_names: Union[str, typing.Set[str]], include_root: bool = True</em><span class="sig-paren">)</span> &#x2192; Iterator[_ForwardRef('Node')]<a class="reference internal" href="_modules/syntaxtree.html#Node.select_by_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.Node.select_by_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator that runs through all descendants that have one
of the given tag names.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">mock_syntax_tree</span><span class="p">(</span><span class="s1">&#39;(a (b &quot;X&quot;) (X (c &quot;d&quot;)) (e (X &quot;F&quot;)))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">flatten_sxpr</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">as_sxpr</span><span class="p">())</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">select_by_tag</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
<span class="go">[&#39;(X (c &quot;d&quot;))&#39;, &#39;(X &quot;F&quot;)&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">flatten_sxpr</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">as_sxpr</span><span class="p">())</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">select_by_tag</span><span class="p">({</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">},</span> <span class="kc">False</span><span class="p">))</span>
<span class="go">[&#39;(b &quot;X&quot;)&#39;, &#39;(X (c &quot;d&quot;))&#39;, &#39;(X &quot;F&quot;)&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">any</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">select_by_tag</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">flatten_sxpr</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">as_sxpr</span><span class="p">())</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">select_by_tag</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
<span class="go">[&#39;(a (b &quot;X&quot;) (X (c &quot;d&quot;)) (e (X &quot;F&quot;)))&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flatten_sxpr</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">select_by_tag</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span><span class="o">.</span><span class="n">as_sxpr</span><span class="p">())</span>
<span class="go">&#39;(X (c &quot;d&quot;))&#39;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tag_name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#set" title="(in Python v3.6)"><em>set</em></a>) – A tag name or set of tag names that is being
searched for</li>
<li><strong>include_root</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a>) – If False, only descendant nodes will be
checked for a match.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last"><em>Node</em> – All nodes which have a given tag name.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="syntaxtree.Node.structure">
<code class="descname">structure</code><a class="headerlink" href="#syntaxtree.Node.structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return structure (and content) as S-expression on a single line
without any line breaks.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">tag_name</code></dt>
<dd><p>Returns the tage name of Node, i.e. the name for XML or
S-expression representation. By default the tag name is the
name of the node’s parser or, if the node’s parser is unnamed, the
node’s parser’s <cite>ptype</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="syntaxtree.Node.tree_size">
<code class="descname">tree_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/syntaxtree.html#Node.tree_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.Node.tree_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively counts the number of nodes in the tree including the root node.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="syntaxtree.mock_syntax_tree">
<code class="descname">mock_syntax_tree</code><span class="sig-paren">(</span><em>sxpr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/syntaxtree.html#mock_syntax_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.mock_syntax_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a tree of nodes from an S-expression. The main purpose of this is
to generate test data.</p>
<p>Example:
&gt;&gt;&gt; mock_syntax_tree(“(a (b c))”).as_sxpr()
‘(an    (bn        “c”n    )n)’</p>
</dd></dl>

<dl class="function">
<dt id="syntaxtree.flatten_sxpr">
<code class="descname">flatten_sxpr</code><span class="sig-paren">(</span><em>sxpr: str</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/syntaxtree.html#flatten_sxpr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#syntaxtree.flatten_sxpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns S-expression <code class="docutils literal notranslate"><span class="pre">sxpr</span></code> as a one-liner without unnecessary
whitespace.</p>
<p>Example:
&gt;&gt;&gt; flatten_sxpr(‘(an    (bn        cn    )n)n’)
‘(a (b c))’</p>
</dd></dl>

</div>
<div class="section" id="module-parse">
<span id="module-parse"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">parse</span></code><a class="headerlink" href="#module-parse" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">parse</span></code> contains the python classes and functions for
DHParser’s packrat-parser. It’s central class is the
<code class="docutils literal notranslate"><span class="pre">Grammar</span></code>-class, which is the base class for any concrete
Grammar. Grammar-objects are callable and parsing is done by
calling a Grammar-object with a source text as argument.</p>
<p>The different parsing functions are callable descendants of class
<code class="docutils literal notranslate"><span class="pre">Parser</span></code>. Usually, they are organized in a tree and defined
within the namespace of a grammar-class. See <code class="docutils literal notranslate"><span class="pre">ebnf.EBNFGrammar</span></code>
for an example.</p>
<dl class="class">
<dt id="parse.Parser">
<em class="property">class </em><code class="descname">Parser</code><span class="sig-paren">(</span><em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Parser" title="Permalink to this definition">¶</a></dt>
<dd><p>(Abstract) Base class for Parser combinator parsers. Any parser
object that is actually used for parsing (i.e. no mock parsers)
should should be derived from this class.</p>
<p>Since parsers can contain other parsers (see classes UnaryOperator
and NaryOperator) they form a cyclical directed graph. A root
parser is a parser from which all other parsers can be reached.
Usually, there is one root parser which serves as the starting
point of the parsing process. When speaking of “the root parser”
it is this root parser object that is meant.</p>
<p>There are two different types of parsers:</p>
<ol class="arabic simple">
<li><em>Named parsers</em> for which a name is set in field <cite>parser.name</cite>.
The results produced by these parsers can later be retrieved in
the AST by the parser name.</li>
<li><em>Anonymous parsers</em> where the name-field just contains the empty
string. AST-transformation of Anonymous parsers can be hooked
only to their class name, and not to the individual parser.</li>
</ol>
<p>Parser objects are callable and parsing is done by calling a parser
object with the text to parse.</p>
<p>If the parser matches it returns a tuple consisting of a node
representing the root of the concrete syntax tree resulting from the
match as well as the substring <cite>text[i:]</cite> where i is the length of
matched text (which can be zero in the case of parsers like
<cite>ZeroOrMore</cite> or <cite>Option</cite>). If <cite>i &gt; 0</cite> then the parser has “moved
forward”.</p>
<p>If the parser does not match it returns <cite>(None, text). **Note** that
this is not the same as an empty match `(“”, text)</cite>. Any empty match
can for example be returned by the <cite>ZeroOrMore</cite>-parser in case the
contained parser is repeated zero times.</p>
<dl class="docutils">
<dt>Attributes and Properties:</dt>
<dd><dl class="first last docutils">
<dt>visited:  Mapping of places this parser has already been to</dt>
<dd>during the current parsing process onto the results the
parser returned at the respective place. This dictionary
is used to implement memoizing.</dd>
<dt>recursion_counter:  Mapping of places to how often the parser</dt>
<dd>has already been called recursively at this place. This
is needed to implement left recursion. The number of
calls becomes irrelevant once a resault has been memoized.</dd>
<dt>cycle_detection:  The apply()-method uses this variable to make</dt>
<dd>sure that one and the same function will not be applied
(recursively) a second time, if it has already been
applied to this parser.</dd>
<dt>grammar:  A reference to the Grammar object to which the parser</dt>
<dd>is attached.</dd>
</dl>
</dd>
</dl>
<dl class="attribute">
<dt id="parse.Parser.ApplyFunc">
<code class="descname">ApplyFunc</code><a class="headerlink" href="#parse.Parser.ApplyFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Callable</span></code></p>
</dd></dl>

<dl class="method">
<dt id="parse.Parser.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>func: Callable[_ForwardRef('Parser'), NoneType]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/parse.html#Parser.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Parser.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies function <cite>func(parser)</cite> recursively to this parser and all
descendant parsers if any exist. The same function can never
be applied twice between calls of the <code class="docutils literal notranslate"><span class="pre">reset()</span></code>-method!
Returns <cite>True</cite>, if function has been applied, <cite>False</cite> if function
had been applied earlier already and thus has not been applied again.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Parser.grammar">
<code class="descname">grammar</code><a class="headerlink" href="#parse.Parser.grammar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Grammar object to which the parser belongs. If not
yet connected to any Grammar object, None is returned.</p>
</dd></dl>

<dl class="method">
<dt id="parse.Parser.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parse.html#Parser.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Parser.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes or resets any parser variables. If overwritten,
the <cite>reset()</cite>-method of the parent class must be called from the
<cite>reset()</cite>-method of the derived class.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="parse.UnknownParserError">
<em class="property">exception </em><code class="descname">UnknownParserError</code><a class="reference internal" href="_modules/parse.html#UnknownParserError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.UnknownParserError" title="Permalink to this definition">¶</a></dt>
<dd><p>UnknownParserError is raised if a Grammer object is called with a
parser that does not exist or if in the course of parsing a parser
is reffered to that does not exist.</p>
</dd></dl>

<dl class="class">
<dt id="parse.Grammar">
<em class="property">class </em><code class="descname">Grammar</code><span class="sig-paren">(</span><em>root: parse.Parser = None</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Grammar" title="Permalink to this definition">¶</a></dt>
<dd><p>Class Grammar directs the parsing process and stores global state
information of the parsers, i.e. state information that is shared
accross parsers.</p>
<p>Grammars are basically collections of parser objects, which are
connected to an instance object of class Grammar. There exist two
ways of connecting parsers to grammar objects: Either by passing
the root parser object to the constructor of a Grammar object
(“direct instantiation”), or by assigning the root parser to the
class variable “<a href="#id1"><span class="problematic" id="id2">root__</span></a>” of a descendant class of class Grammar.</p>
<p>Example for direct instantiation of a grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">number</span> <span class="o">=</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\.&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">number_parser</span> <span class="o">=</span> <span class="n">Grammar</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">number_parser</span><span class="p">(</span><span class="s2">&quot;3.1416&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;3.1416&#39;</span>
</pre></div>
</div>
<p>Collecting the parsers that define a grammar in a descendant class of
class Grammar and assigning the named parsers to class variables
rather than global variables has several advantages:</p>
<ol class="arabic simple">
<li>It keeps the namespace clean.</li>
<li>The parser names of named parsers do not need to be passed to the
constructor of the Parser object explicitly, but it suffices to
assign them to class variables, which results in better
readability of the Python code.</li>
<li>The parsers in the class do not necessarily need to be connected
to one single root parser, which is helpful for testing and
building up a parser successively of several components.</li>
</ol>
<p>As a consequence, though, it is highly recommended that a Grammar
class should not define any other variables or methods with names
that are legal parser names. A name ending with a double
underscore ‘__’ is <em>not</em> a legal parser name and can safely be
used.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Arithmetic</span><span class="p">(</span><span class="n">Grammar</span><span class="p">):</span>
    <span class="c1"># special fields for implicit whitespace and comment configuration</span>
    <span class="n">COMMENT__</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;#.*(?:\n|$)&#39;</span>  <span class="c1"># Python style comments</span>
    <span class="n">wspR__</span> <span class="o">=</span> <span class="n">mixin_comment</span><span class="p">(</span><span class="n">whitespace</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;[\t ]*&#39;</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">COMMENT__</span><span class="p">)</span>

    <span class="c1"># parsers</span>
    <span class="n">expression</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="n">INTEGER</span> <span class="o">=</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">d+&#39;</span><span class="p">)</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">INTEGER</span> <span class="o">|</span> <span class="n">Token</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">expression</span> <span class="o">+</span> <span class="n">Token</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
    <span class="n">term</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">((</span><span class="n">Token</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Token</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="n">factor</span><span class="p">)</span>
    <span class="n">expression</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">term</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">((</span><span class="n">Token</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Token</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="n">term</span><span class="p">))</span>
    <span class="n">root__</span> <span class="o">=</span> <span class="n">expression</span>
</pre></div>
</div>
<p>Upon instantiation the parser objects are deep-copied to the
Grammar object and assigned to object variables of the same name.
Any parser that is directly assigned to a class variable is a
‘named’ parser and its field <cite>parser.name</cite> contains the variable
name after instantiation of the Grammar class. All other parsers,
i.e. parsers that are defined within a <cite>named</cite> parser, remain
“anonymous parsers” where <cite>parser.name</cite> is the empty string, unless
a name has been passed explicitly upon instantiation.
If one and the same parser is assigned to several class variables
such as, for example the parser <cite>expression</cite> in the example above,
the first name sticks.</p>
<p>Grammar objects are callable. Calling a grammar object with a UTF-8
encoded document, initiates the parsing of the document with the
root parser. The return value is the concrete syntax tree. Grammar
objects can be reused (i.e. called again) after parsing. Thus, it
is not necessary to instantiate more than one Grammar object per
thread.</p>
<p>Grammar classes contain a few special class fields for implicit
whitespace and comments that should be overwritten, if the defaults
(no comments, horizontal right aligned whitespace) don’t fit:</p>
<dl class="attribute">
<dt id="parse.Grammar.COMMENT__">
<code class="descname">COMMENT__</code><a class="headerlink" href="#parse.Grammar.COMMENT__" title="Permalink to this definition">¶</a></dt>
<dd><p>regular expression string for matching comments</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.WSP__">
<code class="descname">WSP__</code><a class="headerlink" href="#parse.Grammar.WSP__" title="Permalink to this definition">¶</a></dt>
<dd><p>regular expression for whitespace and comments</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.wspL__">
<code class="descname">wspL__</code><a class="headerlink" href="#parse.Grammar.wspL__" title="Permalink to this definition">¶</a></dt>
<dd><p>regular expression string for left aligned whitespace,
which either equals <a href="#id1"><span class="problematic" id="id3">WSP__</span></a> or is empty.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.wspR__">
<code class="descname">wspR__</code><a class="headerlink" href="#parse.Grammar.wspR__" title="Permalink to this definition">¶</a></dt>
<dd><p>regular expression string for right aligned whitespace,
which either equals <a href="#id1"><span class="problematic" id="id4">WSP__</span></a> or is empty.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.root__">
<code class="descname">root__</code><a class="headerlink" href="#parse.Grammar.root__" title="Permalink to this definition">¶</a></dt>
<dd><p>The root parser of the grammar. Theoretically, all parsers of the
grammar should be reachable by the root parser. However, for testing
of yet incomplete grammars class Grammar does not assume that this
is the case.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.parser_initializiation__">
<code class="descname">parser_initializiation__</code><a class="headerlink" href="#parse.Grammar.parser_initializiation__" title="Permalink to this definition">¶</a></dt>
<dd><p>Before the parser class (!) has been initialized,
which happens upon the first time it is instantiated (see
:func:_assign_parser_names()` for an explanation), this class
field contains a value other than “done”. A value of “done” indicates
that the class has already been initialized.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.all_parsers__">
<code class="descname">all_parsers__</code><a class="headerlink" href="#parse.Grammar.all_parsers__" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of all parsers connected to this grammar object</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.history_tracking__">
<code class="descname">history_tracking__</code><a class="headerlink" href="#parse.Grammar.history_tracking__" title="Permalink to this definition">¶</a></dt>
<dd><p>A flag indicating that the parsing history shall
be tracked</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.wsp_left_parser__">
<code class="descname">wsp_left_parser__</code><a class="headerlink" href="#parse.Grammar.wsp_left_parser__" title="Permalink to this definition">¶</a></dt>
<dd><p>A parser for the default left-adjacent-whitespace
or the :class:zombie-parser if the
default is empty. The default whitespace will be used by parsers
<a class="reference internal" href="#parse.Token" title="parse.Token"><code class="xref py py-class docutils literal notranslate"><span class="pre">Token</span></code></a> and, if no other parsers are passed to its constructor,
by parser <a class="reference internal" href="#parse.RE" title="parse.RE"><code class="xref py py-class docutils literal notranslate"><span class="pre">RE</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.wsp_right_parser__">
<code class="descname">wsp_right_parser__</code><a class="headerlink" href="#parse.Grammar.wsp_right_parser__" title="Permalink to this definition">¶</a></dt>
<dd><p>The same for the default right-adjacent-whitespace.
Both <a href="#id1"><span class="problematic" id="id5">wsp_left_parser__</span></a> and <a href="#id1"><span class="problematic" id="id6">wsp_right_parser__</span></a> merely serve the
purpose to avoid having to specify the default whitespace
explicitly every time an <a class="reference internal" href="#parse.RE" title="parse.RE"><code class="xref py py-class docutils literal notranslate"><span class="pre">RE</span></code></a>-parser-object is created.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar._dirty_flag__">
<code class="descname">_dirty_flag__</code><a class="headerlink" href="#parse.Grammar._dirty_flag__" title="Permalink to this definition">¶</a></dt>
<dd><p>A flag indicating that the Grammar has been called at
least once so that the parsing-variables need to be reset
when it is called again.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.document__">
<code class="descname">document__</code><a class="headerlink" href="#parse.Grammar.document__" title="Permalink to this definition">¶</a></dt>
<dd><p>the text that has most recently been parsed or that is
currently being parsed.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.document_length__">
<code class="descname">document_length__</code><a class="headerlink" href="#parse.Grammar.document_length__" title="Permalink to this definition">¶</a></dt>
<dd><p>the length of the document.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.document_lbreaks__">
<code class="descname">document_lbreaks__</code><a class="headerlink" href="#parse.Grammar.document_lbreaks__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of linebreaks within the document, starting
with -1 and ending with EOF. This helps generating line
and column number for history recording and will only be
initialized if <a class="reference internal" href="#parse.Grammar.history_tracking__" title="parse.Grammar.history_tracking__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">history_tracking__</span></code></a> is true.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar._reversed__">
<code class="descname">_reversed__</code><a class="headerlink" href="#parse.Grammar._reversed__" title="Permalink to this definition">¶</a></dt>
<dd><p>the same text in reverse order - needed by the <cite>Lookbehind</cite>-
parsers.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.variables__">
<code class="descname">variables__</code><a class="headerlink" href="#parse.Grammar.variables__" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping for variable names to a stack of their respective
string values - needed by the <a class="reference internal" href="#parse.Capture" title="parse.Capture"><code class="xref py py-class docutils literal notranslate"><span class="pre">Capture</span></code></a>-, <a class="reference internal" href="#parse.Retrieve" title="parse.Retrieve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Retrieve</span></code></a>-
and <a class="reference internal" href="#parse.Pop" title="parse.Pop"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pop</span></code></a>-parsers.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.rollback__">
<code class="descname">rollback__</code><a class="headerlink" href="#parse.Grammar.rollback__" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of tuples (location, rollback-function) that are
deposited by the <a class="reference internal" href="#parse.Capture" title="parse.Capture"><code class="xref py py-class docutils literal notranslate"><span class="pre">Capture</span></code></a>- and <a class="reference internal" href="#parse.Pop" title="parse.Pop"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pop</span></code></a>-parsers.
If the parsing process reaches a dead end then all
rollback-functions up to the point to which it retreats will be
called and the state of the variable stack restored accordingly.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.last_rb__loc__">
<code class="descname">last_rb__loc__</code><a class="headerlink" href="#parse.Grammar.last_rb__loc__" title="Permalink to this definition">¶</a></dt>
<dd><p>The last, i.e. most advanced location in the text
where a variable changing operation occurred. If the parser
backtracks to a location at or before last_rb__loc__ (i.e.
location &lt;= last_rb__loc__) then a rollback of all variable
changing operations is necessary that occurred after the
location to which the parser backtracks. This is done by
calling method <code class="xref py py-func docutils literal notranslate"><span class="pre">rollback_to__(location)()</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.call_stack__">
<code class="descname">call_stack__</code><a class="headerlink" href="#parse.Grammar.call_stack__" title="Permalink to this definition">¶</a></dt>
<dd><p>A stack of all parsers that have been called. This
is required for recording the parser history (for debugging)
and, eventually, i.e. one day in the future, for tracing through
the parsing process.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.history__">
<code class="descname">history__</code><a class="headerlink" href="#parse.Grammar.history__" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of parser-call-stacks. A parser-call-stack is
appended to the list each time a parser either matches, fails
or if a parser-error occurs.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.moving_forward__">
<code class="descname">moving_forward__</code><a class="headerlink" href="#parse.Grammar.moving_forward__" title="Permalink to this definition">¶</a></dt>
<dd><p>This flag indicates that the parsing process is currently
moving forward . It is needed to reduce noise in history recording
and should not be considered as having a valid value if history
recording is turned off! (See <code class="xref py py-func docutils literal notranslate"><span class="pre">add_parser_guard()</span></code> and its local
function <code class="xref py py-func docutils literal notranslate"><span class="pre">guarded_call()</span></code>)</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.recursion_locations__">
<code class="descname">recursion_locations__</code><a class="headerlink" href="#parse.Grammar.recursion_locations__" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the locations where left recursion was
detected. Needed to provide minimal memoization for the left
recursion detection algorithm, but, strictly speaking, superfluous
if full memoization is enabled. (See <code class="xref py py-func docutils literal notranslate"><span class="pre">add_parser_guard()</span></code> and its
local function <code class="xref py py-func docutils literal notranslate"><span class="pre">guarded_call()</span></code>)</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.memoization__">
<code class="descname">memoization__</code><a class="headerlink" href="#parse.Grammar.memoization__" title="Permalink to this definition">¶</a></dt>
<dd><p>Turns full memoization on or off. Turning memoization off
results in less memory usage and sometimes reduced parsing time.
In some situations it may drastically increase parsing time, so
it is safer to leave it on. (Default: on)</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.left_recursion_handling__">
<code class="descname">left_recursion_handling__</code><a class="headerlink" href="#parse.Grammar.left_recursion_handling__" title="Permalink to this definition">¶</a></dt>
<dd><p>Turns left recursion handling on or off.
If turned off, a recursion error will result in case of left
recursion.</p>
</dd></dl>

<dl class="method">
<dt id="parse.Grammar.push_rollback__">
<code class="descname">push_rollback__</code><span class="sig-paren">(</span><em>location</em>, <em>func</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parse.html#Grammar.push_rollback__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Grammar.push_rollback__" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a rollback function that either removes or re-adds
values on the variable stack (<cite>self.variables</cite>) that have been
added (or removed) by Capture or Pop Parsers, the results of
which have been dismissed.</p>
</dd></dl>

<dl class="attribute">
<dt id="parse.Grammar.reversed__">
<code class="descname">reversed__</code><a class="headerlink" href="#parse.Grammar.reversed__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reversed version of the currently parsed document. As
about the only case where this is needed is the Lookbehind-parser,
this is done lazily.</p>
</dd></dl>

<dl class="method">
<dt id="parse.Grammar.rollback_to__">
<code class="descname">rollback_to__</code><span class="sig-paren">(</span><em>location</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parse.html#Grammar.rollback_to__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Grammar.rollback_to__" title="Permalink to this definition">¶</a></dt>
<dd><p>Rolls back the variable stacks (<cite>self.variables</cite>) to its
state at an earlier location in the parsed document.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parse.PreprocessorToken">
<em class="property">class </em><code class="descname">PreprocessorToken</code><span class="sig-paren">(</span><em>token: str</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#PreprocessorToken"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.PreprocessorToken" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses tokens that have been inserted by a preprocessor.</p>
<p>Preprocessors can generate Tokens with the <code class="docutils literal notranslate"><span class="pre">make_token</span></code>-function.
These tokens start and end with magic characters that can only be
matched by the PreprocessorToken Parser. Such tokens can be used to
insert BEGIN - END delimiters at the beginning or ending of a
quoted block, for example.</p>
</dd></dl>

<dl class="class">
<dt id="parse.RegExp">
<em class="property">class </em><code class="descname">RegExp</code><span class="sig-paren">(</span><em>regexp</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#RegExp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.RegExp" title="Permalink to this definition">¶</a></dt>
<dd><p>Regular expression parser.</p>
<p>The RegExp-parser parses text that matches a regular expression.
RegExp can also be considered as the “atomic parser”, because all
other parsers delegate part of the parsing job to other parsers,
but do not match text directly.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">word</span> <span class="o">=</span> <span class="n">RegExp</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">word</span><span class="p">)(</span><span class="s2">&quot;Haus&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;Haus&#39;</span>
</pre></div>
</div>
<p>EBNF-Notation:  <code class="docutils literal notranslate"><span class="pre">/</span> <span class="pre">...</span> <span class="pre">/</span></code></p>
<p>EBNF-Example:   <code class="docutils literal notranslate"><span class="pre">word</span> <span class="pre">=</span> <span class="pre">/\w+/</span></code></p>
</dd></dl>

<dl class="class">
<dt id="parse.RE">
<em class="property">class </em><code class="descname">RE</code><span class="sig-paren">(</span><em>regexp</em>, <em>wL=None</em>, <em>wR=None</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#RE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.RE" title="Permalink to this definition">¶</a></dt>
<dd><p>Regular Expressions with optional leading or trailing whitespace.</p>
<p>The RE-parser parses pieces of text that match a given regular
expression. Other than the <code class="docutils literal notranslate"><span class="pre">RegExp</span></code>-Parser it can also skip
“implicit whitespace” before or after the matched text.</p>
<p>The whitespace is in turn defined by a regular expression. It should
be made sure that this expression also matches the empty string,
e.g. use r’s*’ or r’[t ]+’, but not r’s+’. If the respective
parameters in the constructor are set to <code class="docutils literal notranslate"><span class="pre">None</span></code> the default
whitespace expression from the Grammar object will be used.</p>
<p>Example (allowing whitespace on the right hand side, but not on
the left hand side of a regular expression):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">word</span> <span class="o">=</span> <span class="n">RE</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w+&#39;</span><span class="p">,</span> <span class="n">wR</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\s*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">Grammar</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">parser</span><span class="p">(</span><span class="s1">&#39;Haus &#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;Haus &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">structure</span>
<span class="go">&#39;(:RE (:RegExp &quot;Haus&quot;) (:Whitespace &quot; &quot;))&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">parser</span><span class="p">(</span><span class="s1">&#39; Haus&#39;</span><span class="p">))</span>
<span class="go">&#39; &lt;&lt;&lt; Error on &quot; Haus&quot; | Parser did not match! Invalid source file?\n    Most advanced: None\n    Last match:    None; &gt;&gt;&gt; &#39;</span>
</pre></div>
</div>
<p>EBNF-Notation:  <code class="docutils literal notranslate"><span class="pre">/</span> <span class="pre">...</span> <span class="pre">/~`</span>&#160; <span class="pre">or</span>&#160; <span class="pre">`~/</span> <span class="pre">...</span> <span class="pre">/`</span>&#160; <span class="pre">or</span>&#160; <span class="pre">`~/</span> <span class="pre">...</span> <span class="pre">/~</span></code></p>
<p>EBNF-Example:   <code class="docutils literal notranslate"><span class="pre">word</span> <span class="pre">=</span> <span class="pre">/\w+/~</span></code></p>
<dl class="method">
<dt id="parse.RE.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>func: Callable[_ForwardRef('Parser'), NoneType]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/parse.html#RE.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.RE.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies function <cite>func(parser)</cite> recursively to this parser and all
descendant parsers if any exist. The same function can never
be applied twice between calls of the <code class="docutils literal notranslate"><span class="pre">reset()</span></code>-method!
Returns <cite>True</cite>, if function has been applied, <cite>False</cite> if function
had been applied earlier already and thus has not been applied again.</p>
</dd></dl>

<dl class="method">
<dt id="parse.RE.create_main_parser">
<code class="descname">create_main_parser</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span> &#x2192; parse.Parser<a class="reference internal" href="_modules/parse.html#RE.create_main_parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.RE.create_main_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the main parser of this compound parser. Can be overridden.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parse.Token">
<em class="property">class </em><code class="descname">Token</code><span class="sig-paren">(</span><em>token: str</em>, <em>wL=None</em>, <em>wR=None</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Token" title="Permalink to this definition">¶</a></dt>
<dd><p>Class Token parses simple strings. Any regular regular expression
commands will be interpreted as simple sequence of characters.</p>
<p>Other than that class Token is essentially a renamed version of
class RE. Because tokens often have a particular semantic different
from other REs, parsing them with a separate parser class allows to
distinguish them by their parser type.</p>
<dl class="method">
<dt id="parse.Token.create_main_parser">
<code class="descname">create_main_parser</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span> &#x2192; parse.Parser<a class="reference internal" href="_modules/parse.html#Token.create_main_parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Token.create_main_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the main parser of this compound parser. Can be overridden.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="parse.mixin_comment">
<code class="descname">mixin_comment</code><span class="sig-paren">(</span><em>whitespace: str</em>, <em>comment: str</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/parse.html#mixin_comment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.mixin_comment" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a regular expression that merges comment and whitespace
regexps. Thus comments cann occur whereever whitespace is allowed
and will be skipped just as implicit whitespace.</p>
<p>Note, that because this works on the level of regular expressions,
nesting comments is not possible. It also makes it much harder to
use directives inside comments (which isn’t recommended, anyway).</p>
</dd></dl>

<dl class="class">
<dt id="parse.Synonym">
<em class="property">class </em><code class="descname">Synonym</code><span class="sig-paren">(</span><em>parser: parse.Parser</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Synonym"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Synonym" title="Permalink to this definition">¶</a></dt>
<dd><p>Simply calls another parser and encapsulates the result in
another node if that parser matches.</p>
<p>This parser is needed to support synonyms in EBNF, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jahr</span>       <span class="o">=</span> <span class="n">JAHRESZAHL</span>
<span class="n">JAHRESZAHL</span> <span class="o">=</span> <span class="o">/</span>\<span class="n">d</span>\<span class="n">d</span>\<span class="n">d</span>\<span class="n">d</span><span class="o">/</span>
</pre></div>
</div>
<p>Otherwise the first line could not be represented by any parser
class, in which case it would be unclear whether the parser
RE(‘dddd’) carries the name ‘JAHRESZAHL’ or ‘jahr’.</p>
</dd></dl>

<dl class="class">
<dt id="parse.Option">
<em class="property">class </em><code class="descname">Option</code><span class="sig-paren">(</span><em>parser: parse.Parser</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Option"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Option" title="Permalink to this definition">¶</a></dt>
<dd><p>Parser <code class="docutils literal notranslate"><span class="pre">Option</span></code> always matches, even if its child-parser
did not match.</p>
<p>If the child-parser did not match <code class="docutils literal notranslate"><span class="pre">Option</span></code> returns a node
with no content and does not move forward in the text.</p>
<p>If the child-parser did match, <code class="docutils literal notranslate"><span class="pre">Option</span></code> returns the a node
with the node returnd by the child-parser as its single
child and the text at the position where the child-parser
left it.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">number</span> <span class="o">=</span> <span class="n">Option</span><span class="p">(</span><span class="n">Token</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="n">RegExp</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Option</span><span class="p">(</span><span class="n">RegExp</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\.\d+&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">number</span><span class="p">)(</span><span class="s1">&#39;3.14159&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;3.14159&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">number</span><span class="p">)(</span><span class="s1">&#39;3.14159&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">structure</span>
<span class="go">&#39;(:Series (:Option) (:RegExp &quot;3&quot;) (:Option (:RegExp &quot;.14159&quot;)))&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">number</span><span class="p">)(</span><span class="s1">&#39;-1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;-1&#39;</span>
</pre></div>
</div>
<p>EBNF-Notation: <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">...</span> <span class="pre">]</span></code></p>
<p>EBNF-Example:  <code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">=</span> <span class="pre">[&quot;-&quot;]</span>&#160; <span class="pre">/\d+/</span>&#160; <span class="pre">[</span> <span class="pre">/\.\d+/</span> <span class="pre">]</span></code></p>
</dd></dl>

<dl class="class">
<dt id="parse.ZeroOrMore">
<em class="property">class </em><code class="descname">ZeroOrMore</code><span class="sig-paren">(</span><em>parser: parse.Parser</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#ZeroOrMore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.ZeroOrMore" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>ZeroOrMore</cite> applies a parser repeatedly as long as this parser
matches. Like <cite>Option</cite> the <cite>ZeroOrMore</cite> parser always matches. In
case of zero repetitions, the empty match <cite>((), text)</cite> is returned.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sentence</span> <span class="o">=</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">RE</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w+,?&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="n">Token</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">sentence</span><span class="p">)(</span><span class="s1">&#39;Wo viel der Weisheit, da auch viel des Grämens.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;Wo viel der Weisheit, da auch viel des Grämens.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">sentence</span><span class="p">)(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>  <span class="c1"># an empty sentence also matches</span>
<span class="go">&#39;.&#39;</span>
</pre></div>
</div>
<p>EBNF-Notation: <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code></p>
<p>EBNF-Example:  <code class="docutils literal notranslate"><span class="pre">sentence</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">/\w+,?/</span> <span class="pre">}</span> <span class="pre">&quot;.&quot;</span></code></p>
</dd></dl>

<dl class="class">
<dt id="parse.OneOrMore">
<em class="property">class </em><code class="descname">OneOrMore</code><span class="sig-paren">(</span><em>parser: parse.Parser</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#OneOrMore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.OneOrMore" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>OneOrMore</cite> applies a parser repeatedly as long as this parser
matches. Other than <cite>ZeroOrMore</cite> which always matches, at least
one match is required by <cite>OneOrMore</cite>.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sentence</span> <span class="o">=</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">RE</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w+,?&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="n">Token</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">sentence</span><span class="p">)(</span><span class="s1">&#39;Wo viel der Weisheit, da auch viel des Grämens.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;Wo viel der Weisheit, da auch viel des Grämens.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">Grammar</span><span class="p">(</span><span class="n">sentence</span><span class="p">)(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>  <span class="c1"># an empty sentence also matches</span>
<span class="go">&#39; &lt;&lt;&lt; Error on &quot;.&quot; | Parser did not match! Invalid source file?\n    Most advanced: None\n    Last match:    None; &gt;&gt;&gt; &#39;</span>
</pre></div>
</div>
<p>EBNF-Notation: <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">...</span> <span class="pre">}+</span></code></p>
<p>EBNF-Example:  <code class="docutils literal notranslate"><span class="pre">sentence</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">/\w+,?/</span> <span class="pre">}+</span></code></p>
</dd></dl>

<dl class="class">
<dt id="parse.Series">
<em class="property">class </em><code class="descname">Series</code><span class="sig-paren">(</span><em>*parsers</em>, <em>mandatory: int = 1000</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Series"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Series" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches if each of a series of parsers matches exactly in the order of
the series.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">variable_name</span> <span class="o">=</span> <span class="n">RegExp</span><span class="p">(</span><span class="s1">&#39;(?!\d)\w&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\w*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">variable_name</span><span class="p">)(</span><span class="s1">&#39;variable_1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;variable_1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">Grammar</span><span class="p">(</span><span class="n">variable_name</span><span class="p">)(</span><span class="s1">&#39;1_variable&#39;</span><span class="p">))</span>
<span class="go">&#39; &lt;&lt;&lt; Error on &quot;1_variable&quot; | Parser did not match! Invalid source file?\n    Most advanced: None\n    Last match:    None; &gt;&gt;&gt; &#39;</span>
</pre></div>
</div>
<p>EBNF-Notation: <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">...</span></code>    (sequence of parsers separated by a blank or new line)</p>
<p>EBNF-Example:  <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">=</span> <span class="pre">letter</span> <span class="pre">letter_or_digit</span></code></p>
<dl class="staticmethod">
<dt id="parse.Series.combined_mandatory">
<em class="property">static </em><code class="descname">combined_mandatory</code><span class="sig-paren">(</span><em>right: parse.Parser</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parse.html#Series.combined_mandatory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Series.combined_mandatory" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position of the first mandatory element (if any) when
parsers <cite>left</cite> and <cite>right</cite> are joined to a sequence.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parse.Alternative">
<em class="property">class </em><code class="descname">Alternative</code><span class="sig-paren">(</span><em>*parsers</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Alternative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Alternative" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches if one of several alternatives matches. Returns
the first match.</p>
<p>This parser represents the EBNF-operator “|” with the qualification
that both the symmetry and the ambiguity of the EBNF-or-operator
are broken by selecting the first match.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># the order of the sub-expression matters!</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">number</span> <span class="o">=</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\.&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span><span class="p">(</span><span class="n">Grammar</span><span class="p">(</span><span class="n">number</span><span class="p">)(</span><span class="s2">&quot;3.1416&quot;</span><span class="p">))</span>
<span class="s1">&#39;3 &lt;&lt;&lt; Error on &quot;.141&quot; | Parser stopped before end! trying to recover... &gt;&gt;&gt; &#39;</span>

<span class="c1"># the most selective expression should be put first:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">number</span> <span class="o">=</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\.&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Grammar</span><span class="p">(</span><span class="n">number</span><span class="p">)(</span><span class="s2">&quot;3.1416&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="s1">&#39;3.1416&#39;</span>
</pre></div>
</div>
<p>EBNF-Notation: <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">|</span> <span class="pre">...</span></code></p>
<p>EBNF-Example:  <code class="docutils literal notranslate"><span class="pre">sentence</span> <span class="pre">=</span> <span class="pre">/\d+\.\d+/</span> <span class="pre">|</span> <span class="pre">/\d+/</span></code></p>
<dl class="method">
<dt id="parse.Alternative.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parse.html#Alternative.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Alternative.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes or resets any parser variables. If overwritten,
the <cite>reset()</cite>-method of the parent class must be called from the
<cite>reset()</cite>-method of the derived class.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parse.AllOf">
<em class="property">class </em><code class="descname">AllOf</code><span class="sig-paren">(</span><em>*parsers</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#AllOf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.AllOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches if all elements of a list of parsers match. Each parser must
match exactly once. Other than in a sequence, the order in which
the parsers match is arbitrary, however.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prefixes</span> <span class="o">=</span> <span class="n">AllOf</span><span class="p">(</span><span class="n">Token</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">Token</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)(</span><span class="s1">&#39;A B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;A B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)(</span><span class="s1">&#39;B A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;B A&#39;</span>
</pre></div>
</div>
<p>EBNF-Notation: <code class="docutils literal notranslate"><span class="pre">&lt;...</span> <span class="pre">...&gt;</span></code>    (sequence of parsers enclosed by angular brackets)</p>
<p>EBNF-Example:  <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">=</span> <span class="pre">&lt;letter</span> <span class="pre">letter_or_digit&gt;</span></code></p>
</dd></dl>

<dl class="class">
<dt id="parse.SomeOf">
<em class="property">class </em><code class="descname">SomeOf</code><span class="sig-paren">(</span><em>*parsers</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#SomeOf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.SomeOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches if at least one element of a list of parsers match. No parser
must match more than once . Other than in a sequence, the order in which
the parsers match is arbitrary, however.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prefixes</span> <span class="o">=</span> <span class="n">SomeOf</span><span class="p">(</span><span class="n">Token</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">Token</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)(</span><span class="s1">&#39;A B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;A B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)(</span><span class="s1">&#39;B A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;B A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Grammar</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;B&#39;</span>
</pre></div>
</div>
<p>EBNF-Notation: <code class="docutils literal notranslate"><span class="pre">&lt;...</span> <span class="pre">...&gt;</span></code>    (sequence of parsers enclosed by angular brackets)</p>
<p>EBNF-Example:  <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">=</span> <span class="pre">&lt;letter</span> <span class="pre">letter_or_digit&gt;</span></code></p>
</dd></dl>

<dl class="function">
<dt id="parse.Unordered">
<code class="descname">Unordered</code><span class="sig-paren">(</span><em>parser: parse.NaryOperator</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; parse.NaryOperator<a class="reference internal" href="_modules/parse.html#Unordered"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Unordered" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an AllOf- or SomeOf-parser depending on whether <cite>parser</cite>
is a Series (AllOf) or an Alternative (SomeOf).</p>
</dd></dl>

<dl class="class">
<dt id="parse.Lookahead">
<em class="property">class </em><code class="descname">Lookahead</code><span class="sig-paren">(</span><em>parser: parse.Parser</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Lookahead"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Lookahead" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches, if the contained parser would match for the following text,
but does not consume any text.</p>
</dd></dl>

<dl class="class">
<dt id="parse.NegativeLookahead">
<em class="property">class </em><code class="descname">NegativeLookahead</code><span class="sig-paren">(</span><em>parser: parse.Parser</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#NegativeLookahead"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.NegativeLookahead" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches, if the contained parser would <em>not</em> match for the following
text.</p>
<dl class="method">
<dt id="parse.NegativeLookahead.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>bool_value</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/parse.html#NegativeLookahead.sign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.NegativeLookahead.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value. Can be overriden to return the inverted bool.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parse.Lookbehind">
<em class="property">class </em><code class="descname">Lookbehind</code><span class="sig-paren">(</span><em>parser: parse.Parser</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Lookbehind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Lookbehind" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches, if the contained parser would match backwards. Requires
the contained parser to be a RegExp, RE, PlainText or Token parser.</p>
<p>EXPERIMENTAL</p>
</dd></dl>

<dl class="class">
<dt id="parse.NegativeLookbehind">
<em class="property">class </em><code class="descname">NegativeLookbehind</code><span class="sig-paren">(</span><em>parser: parse.Parser</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#NegativeLookbehind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.NegativeLookbehind" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches, if the contained parser would <em>not</em> match backwards. Requires
the contained parser to be a RegExp-parser.</p>
<dl class="method">
<dt id="parse.NegativeLookbehind.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>bool_value</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/parse.html#NegativeLookbehind.sign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.NegativeLookbehind.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value. Can be overriden to return the inverted bool.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parse.Capture">
<em class="property">class </em><code class="descname">Capture</code><span class="sig-paren">(</span><em>parser: parse.Parser</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Capture"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Capture" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the contained parser and, in case of a match, saves the result
in a variable. A variable is a stack of values associated with the
contained parser’s name. This requires the contained parser to be named.</p>
</dd></dl>

<dl class="class">
<dt id="parse.Retrieve">
<em class="property">class </em><code class="descname">Retrieve</code><span class="sig-paren">(</span><em>symbol: parse.Parser, rfilter: Callable[List[str], str] = None, name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Retrieve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Retrieve" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches if the following text starts with the value of a particular
variable. As a variable in this context means a stack of values,
the last value will be compared with the following text. It will not
be removed from the stack! (This is the difference between the
<cite>Retrieve</cite> and the <cite>Pop</cite> parser.)
The constructor parameter <cite>symbol</cite> determines which variable is
used.</p>
<dl class="method">
<dt id="parse.Retrieve.retrieve_and_match">
<code class="descname">retrieve_and_match</code><span class="sig-paren">(</span><em>text: DHParser.stringview.StringView</em><span class="sig-paren">)</span> &#x2192; Tuple[Union[DHParser.syntaxtree.Node, NoneType], DHParser.stringview.StringView]<a class="reference internal" href="_modules/parse.html#Retrieve.retrieve_and_match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Retrieve.retrieve_and_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves variable from stack through the filter function passed to
the class’ constructor and tries to match the variable’s value with
the following text. Returns a Node containing the value or <cite>None</cite>
accordingly.</p>
<p>This functionality has been move from the __call__ method to an
independent method to allow calling it from a subclasses __call__
method without triggering the parser guard a second time.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parse.Pop">
<em class="property">class </em><code class="descname">Pop</code><span class="sig-paren">(</span><em>symbol: parse.Parser, rfilter: Callable[List[str], str] = None, name: str = ''</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/parse.html#Pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches if the following text starts with the value of a particular
variable. As a variable in this context means a stack of values,
the last value will be compared with the following text. Other
than the <cite>Retrieve</cite>-parser, the <cite>Pop</cite>-parser removes the value
from the stack in case of a match.</p>
<p>The constructor parameter <cite>symbol</cite> determines which variable is
used.</p>
</dd></dl>

<dl class="class">
<dt id="parse.Forward">
<em class="property">class </em><code class="descname">Forward</code><a class="reference internal" href="_modules/parse.html#Forward"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward allows to declare a parser before it is actually defined.
Forward declarations are needed for parsers that are recursively
nested, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Arithmetic</span><span class="p">(</span><span class="n">Grammar</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    expression =  term  { (&quot;+&quot; | &quot;-&quot;) term }</span>
<span class="sd">    term       =  factor  { (&quot;*&quot; | &quot;/&quot;) factor }</span>
<span class="sd">    factor     =  INTEGER | &quot;(&quot;  expression  &quot;)&quot;</span>
<span class="sd">    INTEGER    =  /\d+/~</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">expression</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="n">INTEGER</span>    <span class="o">=</span> <span class="n">RE</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">d+&#39;</span><span class="p">)</span>
    <span class="n">factor</span>     <span class="o">=</span> <span class="n">INTEGER</span> <span class="o">|</span> <span class="n">Token</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">expression</span> <span class="o">+</span> <span class="n">Token</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
    <span class="n">term</span>       <span class="o">=</span> <span class="n">factor</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">((</span><span class="n">Token</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Token</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="n">factor</span><span class="p">)</span>
    <span class="n">expression</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">term</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">((</span><span class="n">Token</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Token</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="n">term</span><span class="p">))</span>
    <span class="n">root__</span>     <span class="o">=</span> <span class="n">expression</span>
</pre></div>
</div>
<dl class="method">
<dt id="parse.Forward.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>func: Callable[_ForwardRef('Parser'), NoneType]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/parse.html#Forward.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Forward.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies function <cite>func(parser)</cite> recursively to this parser and all
descendant parsers if any exist. The same function can never
be applied twice between calls of the <code class="docutils literal notranslate"><span class="pre">reset()</span></code>-method!
Returns <cite>True</cite>, if function has been applied, <cite>False</cite> if function
had been applied earlier already and thus has not been applied again.</p>
</dd></dl>

<dl class="method">
<dt id="parse.Forward.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>parser: parse.Parser</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parse.html#Forward.set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parse.Forward.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the parser to which the calls to this Forward-object
shall be delegated.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-transform">
<span id="module-transform"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">transform</span></code><a class="headerlink" href="#module-transform" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">transform</span></code> contains the functions for transforming the
concrete syntax tree (CST) into an abstract syntax tree (AST).</p>
<p>As these functions are very generic, they can in principle be
used for any kind of tree transformations, not necessarily only
for CST -&gt; AST transformations.</p>
<dl class="attribute">
<dt id="transform.TransformationDict">
<code class="descname">TransformationDict</code><a class="headerlink" href="#transform.TransformationDict" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Dict" title="(in Python v3.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Dict</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="transform.TransformationProc">
<code class="descname">TransformationProc</code><a class="headerlink" href="#transform.TransformationProc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Callable</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="transform.ConditionFunc">
<code class="descname">ConditionFunc</code><a class="headerlink" href="#transform.ConditionFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Callable</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="transform.KeyFunc">
<code class="descname">KeyFunc</code><a class="headerlink" href="#transform.KeyFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Callable</span></code></p>
</dd></dl>

<dl class="function">
<dt id="transform.transformation_factory">
<code class="descname">transformation_factory</code><span class="sig-paren">(</span><em>t1=None</em>, <em>t2=None</em>, <em>t3=None</em>, <em>t4=None</em>, <em>t5=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#transformation_factory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.transformation_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates factory functions from transformation-functions that
dispatch on the first parameter after the context parameter.</p>
<p>Decorating a transformation-function that has more than merely the
<code class="docutils literal notranslate"><span class="pre">node</span></code>-parameter with <code class="docutils literal notranslate"><span class="pre">transformation_factory</span></code> creates a
function with the same name, which returns a partial-function that
takes just the context-parameter.</p>
<p>Additionally, there is some some syntactic sugar for
transformation-functions that receive a collection as their second
parameter and do not have any further parameters. In this case a
list of parameters passed to the factory function will be converted
into a collection.</p>
<p>Main benefit is readability of processing tables.</p>
<p>Usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@transformation_factory</span><span class="p">(</span><span class="n">AbstractSet</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">remove_tokens</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>or, alternatively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@transformation_factory</span>
<span class="k">def</span> <span class="nf">remove_tokens</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">AbstractSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">trans_table</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;expression&#39;</span><span class="p">:</span> <span class="n">remove_tokens</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">trans_table</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;expression&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">remove_tokens</span><span class="p">,</span> <span class="n">tokens</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">})</span> <span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>t1</strong> – type of the second argument of the transformation function,
only necessary if the transformation functions’ parameter list
does not have type annotations.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="transform.traverse">
<code class="descname">traverse</code><span class="sig-paren">(</span><em>root_node: DHParser.syntaxtree.Node, processing_table: Dict[str, Union[typing.Sequence[typing.Callable], typing.Dict[str, typing.Sequence[typing.Callable]]]], key_func: Callable[DHParser.syntaxtree.Node, str] = &lt;function key_tag_name&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/transform.html#traverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.traverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Traverses the snytax tree starting with the given <code class="docutils literal notranslate"><span class="pre">node</span></code> depth
first and applies the sequences of callback-functions registered
in the <code class="docutils literal notranslate"><span class="pre">processing_table</span></code>-dictionary.</p>
<p>The most important use case is the transformation of a concrete
syntax tree into an abstract tree (AST). But it is also imaginable
to employ tree-traversal for the semantic analysis of the AST.</p>
<p>In order to assign sequences of callback-functions to nodes, a
dictionary (“processing table”) is used. The keys usually represent
tag names, but any other key function is possible. There exist
three special keys:</p>
<ul class="simple">
<li>‘+’: always called (before any other processing function)</li>
<li>‘*’: called for those nodes for which no (other) processing
function appears in the table</li>
<li>‘~’: always called (after any other processing function)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>root_node</strong> (<a class="reference internal" href="#syntaxtree.Node" title="syntaxtree.Node"><em>Node</em></a>) – The root-node of the syntax tree to be traversed</li>
<li><strong>processing_table</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)"><em>dict</em></a>) – node key -&gt; sequence of functions that
will be applied to matching nodes in order. This dictionary
is interpreted as a <code class="docutils literal notranslate"><span class="pre">compact_table</span></code>. See
<code class="xref py py-func docutils literal notranslate"><span class="pre">expand_table()</span></code> or <code class="xref py py-func docutils literal notranslate"><span class="pre">EBNFCompiler.EBNFTransTable()</span></code></li>
<li><strong>key_func</strong> (<em>function</em>) – A mapping key_func(node) -&gt; keystr. The default
key_func yields node.parser.name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;term&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">replace_by_single_child</span><span class="p">,</span> <span class="n">flatten</span><span class="p">],</span>
          <span class="s2">&quot;factor, flowmarker, retrieveop&quot;</span><span class="p">:</span> <span class="n">replace_by_single_child</span> <span class="p">}</span>
<span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="transform.is_named">
<code class="descname">is_named</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/transform.html#is_named"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.is_named" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the current node’s parser is a named parser.</p>
</dd></dl>

<dl class="function">
<dt id="transform.replace_by_single_child">
<code class="descname">replace_by_single_child</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#replace_by_single_child"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.replace_by_single_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes single branch node, replacing it by its immediate descendant.
Replacement only takes place, if the last node in the context has
exactly one child.</p>
</dd></dl>

<dl class="function">
<dt id="transform.reduce_single_child">
<code class="descname">reduce_single_child</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#reduce_single_child"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.reduce_single_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces a single branch node by transferring the result of its
immediate descendant to this node, but keeping this node’s parser entry.
Reduction only takes place if the last node in the context has
exactly one child.</p>
</dd></dl>

<dl class="function">
<dt id="transform.replace_or_reduce">
<code class="descname">replace_or_reduce</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], condition: Callable = &lt;function is_named&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#replace_or_reduce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.replace_or_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces node by a single child, if condition is met on child,
otherwise (i.e. if the child is anonymous) reduces the child.</p>
</dd></dl>

<dl class="function">
<dt id="transform.replace_parser">
<code class="descname">replace_parser</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], name: str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#replace_parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.replace_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the parser of a Node with a mock parser with the given
name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>context</strong> – the context where the parser shall be replaced</li>
<li><strong>name</strong> – “NAME:PTYPE” of the surrogate. The ptype is optional</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="transform.collapse">
<code class="descname">collapse</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#collapse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.collapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Collapses all sub-nodes of a node by replacing them with the
string representation of the node.</p>
</dd></dl>

<dl class="function">
<dt id="transform.merge_children">
<code class="descname">merge_children</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], tag_names: List[str]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#merge_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.merge_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Joins all children next to each other and with particular tag-names
into a single child node with a mock-parser with the name of the
first tag-name in the list.</p>
</dd></dl>

<dl class="function">
<dt id="transform.replace_content">
<code class="descname">replace_content</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], func: Callable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#replace_content"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.replace_content" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the content of the node. <code class="docutils literal notranslate"><span class="pre">func</span></code> takes the node’s result
as an argument an returns the mapped result.</p>
</dd></dl>

<dl class="function">
<dt id="transform.apply_if">
<code class="descname">apply_if</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], transformation: Callable, condition: Callable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#apply_if"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.apply_if" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a transformation only if a certain condition is met.</p>
</dd></dl>

<dl class="function">
<dt id="transform.apply_unless">
<code class="descname">apply_unless</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], transformation: Callable, condition: Callable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#apply_unless"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.apply_unless" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a transformation if a certain condition is <em>not</em> met.</p>
</dd></dl>

<dl class="function">
<dt id="transform.traverse_locally">
<code class="descname">traverse_locally</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], processing_table: Dict, key_func: Callable = &lt;function key_tag_name&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#traverse_locally"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.traverse_locally" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the syntax tree starting from the last node in the context
according to the given processing table. The purpose of this function is
to apply certain transformations locally, i.e. only for those nodes that
have the last node in the context as their parent node.</p>
</dd></dl>

<dl class="function">
<dt id="transform.is_anonymous">
<code class="descname">is_anonymous</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/transform.html#is_anonymous"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.is_anonymous" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the current node’s parser is an anonymous parser.</p>
</dd></dl>

<dl class="function">
<dt id="transform.is_whitespace">
<code class="descname">is_whitespace</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/transform.html#is_whitespace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.is_whitespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes whitespace and comments defined with the
<code class="docutils literal notranslate"><span class="pre">&#64;comment</span></code>-directive.</p>
</dd></dl>

<dl class="function">
<dt id="transform.is_empty">
<code class="descname">is_empty</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/transform.html#is_empty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the current node’s content is empty.</p>
</dd></dl>

<dl class="function">
<dt id="transform.is_expendable">
<code class="descname">is_expendable</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/transform.html#is_expendable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.is_expendable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the current node either is a node containing
whitespace or an empty node.</p>
</dd></dl>

<dl class="function">
<dt id="transform.is_token">
<code class="descname">is_token</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], tokens: AbstractSet[str] = frozenset()</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/transform.html#is_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.is_token" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the last node in the context has <cite>ptype == TOKEN_PTYPE</cite>
and it’s content matches one of the given tokens. Leading and trailing
whitespace-tokens will be ignored. In case an empty set of tokens is passed,
any token is a match. If only “:” is given all anonymous tokens but no other
tokens are a match.</p>
</dd></dl>

<dl class="function">
<dt id="transform.is_one_of">
<code class="descname">is_one_of</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], tag_name_set: AbstractSet[str]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/transform.html#is_one_of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.is_one_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true, if the node’s tag_name is one of the given tag names.</p>
</dd></dl>

<dl class="function">
<dt id="transform.has_content">
<code class="descname">has_content</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], regexp: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/transform.html#has_content"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.has_content" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks a node’s content against a regular expression.</p>
<p>In contrast to <code class="docutils literal notranslate"><span class="pre">re.match</span></code> the regular expression must match the complete
string and not just the beginning of the string to succeed!</p>
</dd></dl>

<dl class="function">
<dt id="transform.has_parent">
<code class="descname">has_parent</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], tag_name_set: AbstractSet[str]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/transform.html#has_parent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.has_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a node with one of the given tag names appears somewhere
in the context before the last node in the context.</p>
</dd></dl>

<dl class="function">
<dt id="transform.lstrip">
<code class="descname">lstrip</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], condition: Callable = &lt;function is_expendable&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#lstrip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.lstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively removes all leading child-nodes that fulfill a given condition.</p>
</dd></dl>

<dl class="function">
<dt id="transform.rstrip">
<code class="descname">rstrip</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], condition: Callable = &lt;function is_expendable&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#rstrip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.rstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively removes all leading nodes that fulfill a given condition.</p>
</dd></dl>

<dl class="function">
<dt id="transform.strip">
<code class="descname">strip</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], condition: Callable = &lt;function is_expendable&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#strip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.strip" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes leading and trailing child-nodes that fulfill a given condition.</p>
</dd></dl>

<dl class="function">
<dt id="transform.keep_children">
<code class="descname">keep_children</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], section: slice = slice(None, None, None)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#keep_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.keep_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Keeps only child-nodes which fall into a slice of the result field.</p>
</dd></dl>

<dl class="function">
<dt id="transform.keep_children_if">
<code class="descname">keep_children_if</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], condition: Callable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#keep_children_if"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.keep_children_if" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all children for which <cite>condition()</cite> returns <cite>True</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="transform.keep_tokens">
<code class="descname">keep_tokens</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], tokens: AbstractSet[str] = frozenset()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#keep_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.keep_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes any among a particular set of tokens from the immediate
descendants of a node. If <code class="docutils literal notranslate"><span class="pre">tokens</span></code> is the empty set, all tokens
are removed.</p>
</dd></dl>

<dl class="function">
<dt id="transform.keep_nodes">
<code class="descname">keep_nodes</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], tag_names: AbstractSet[str]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#keep_nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.keep_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes children by tag name.</p>
</dd></dl>

<dl class="function">
<dt id="transform.keep_content">
<code class="descname">keep_content</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], regexp: str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#keep_content"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.keep_content" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes children depending on their string value.</p>
</dd></dl>

<dl class="function">
<dt id="transform.remove_children_if">
<code class="descname">remove_children_if</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], condition: Callable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#remove_children_if"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.remove_children_if" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all children for which <cite>condition()</cite> returns <cite>True</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="transform.remove_nodes">
<code class="descname">remove_nodes</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], tag_names: AbstractSet[str]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#remove_nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.remove_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes children by tag name.</p>
</dd></dl>

<dl class="function">
<dt id="transform.remove_content">
<code class="descname">remove_content</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], regexp: str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#remove_content"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.remove_content" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes children depending on their string value.</p>
</dd></dl>

<dl class="function">
<dt id="transform.remove_tokens">
<code class="descname">remove_tokens</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], tokens: AbstractSet[str] = frozenset()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#remove_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.remove_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes any among a particular set of tokens from the immediate
descendants of a node. If <code class="docutils literal notranslate"><span class="pre">tokens</span></code> is the empty set, all tokens
are removed.</p>
</dd></dl>

<dl class="function">
<dt id="transform.flatten">
<code class="descname">flatten</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], condition: Callable = &lt;function is_anonymous&gt;, recursive: bool = True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#flatten"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens all children, that fulfil the given <code class="docutils literal notranslate"><span class="pre">condition</span></code>
(default: all unnamed children). Flattening means that wherever a
node has child nodes, the child nodes are inserted in place of the
node.</p>
<p>If the parameter <code class="docutils literal notranslate"><span class="pre">recursive</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> the same will recursively be
done with the child-nodes, first. In other words, all leaves of
this node and its child nodes are collected in-order as direct
children of this node.</p>
<p>Applying flatten recursively will result in these kinds of
structural transformation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="o">+</span> <span class="mi">3</span><span class="p">)</span>     <span class="o">-&gt;</span>   <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">))))</span>  <span class="o">-&gt;</span>   <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="transform.assert_condition">
<code class="descname">assert_condition</code><span class="sig-paren">(</span><em>context: List[DHParser.syntaxtree.Node], condition: Callable, error_msg: str = ''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/transform.html#assert_condition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#transform.assert_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks for <cite>condition</cite>; adds an error message if condition is not met.</p>
</dd></dl>

</div>
<div class="section" id="module-compile">
<span id="module-compile"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">compile</span></code><a class="headerlink" href="#module-compile" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">compile</span></code> contains a skeleton class for syntax
driven compilation support. Class <code class="docutils literal notranslate"><span class="pre">Compiler</span></code> can serve as base
class for a compiler. Compiler objects
are callable an receive the Abstract syntax tree (AST)
as argument and yield whatever output the compiler produces. In
most Digital Humanities applications this will be
XML-code. However, it can also be anything else, like binary
code or, as in the case of DHParser’s EBNF-compiler, Python
source code.</p>
<p>Function <code class="docutils literal notranslate"><span class="pre">compile_source</span></code> invokes all stages of the compilation
process, i.e. pre-processing, parsing, CST to AST-transformation
and compilation.</p>
<p>See module <code class="docutils literal notranslate"><span class="pre">ebnf</span></code> for a sample of the implementation of a
compiler object.</p>
<dl class="exception">
<dt id="compile.CompilerError">
<em class="property">exception </em><code class="descname">CompilerError</code><a class="reference internal" href="_modules/compile.html#CompilerError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#compile.CompilerError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised when an error of the compiler itself is detected.
Compiler errors are not to be confused with errors in the source
code to be compiled, which do not raise Exceptions but are merely
reported as an error.</p>
</dd></dl>

<dl class="class">
<dt id="compile.Compiler">
<em class="property">class </em><code class="descname">Compiler</code><span class="sig-paren">(</span><em>grammar_name=''</em>, <em>grammar_source=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/compile.html#Compiler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#compile.Compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Class Compiler is the abstract base class for compilers. Compiler
objects are callable and take the root node of the abstract
syntax tree (AST) as argument and return the compiled code in a
format chosen by the compiler itself.</p>
<p>Subclasses implementing a compiler must define <cite>on_XXX()</cite>-methods
for each node name that can occur in the AST where ‘XXX’ is the
node’s name(for unnamed nodes it is the node’s ptype without the
leading colon ‘:’).</p>
<p>These compiler methods take the node on which they are run as
argument. Other than in the AST transformation, which runs depth-first,
compiler methods are called forward moving starting with the root
node, and they are responsible for compiling the child nodes
themselves. This should be done by invoking the <cite>compile(node)</cite>-
method which will pick the right <cite>on_XXX</cite>-method. It is not
recommended to call the <cite>on_XXX</cite>-methods directly.</p>
<dl class="attribute">
<dt id="compile.Compiler.context">
<code class="descname">context</code><a class="headerlink" href="#compile.Compiler.context" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of parent nodes that ends with the currently
compiled node.</p>
</dd></dl>

<dl class="attribute">
<dt id="compile.Compiler.grammar_name">
<code class="descname">grammar_name</code><a class="headerlink" href="#compile.Compiler.grammar_name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the grammar this compiler is related to</p>
</dd></dl>

<dl class="attribute">
<dt id="compile.Compiler.grammar_source">
<code class="descname">grammar_source</code><a class="headerlink" href="#compile.Compiler.grammar_source" title="Permalink to this definition">¶</a></dt>
<dd><p>The source code of the grammar this compiler is
related to.</p>
</dd></dl>

<dl class="attribute">
<dt id="compile.Compiler._dirty_flag">
<code class="descname">_dirty_flag</code><a class="headerlink" href="#compile.Compiler._dirty_flag" title="Permalink to this definition">¶</a></dt>
<dd><p>A flag indicating that the compiler has already been
called at least once and that therefore all compilation
variables must be reset when it is called again.</p>
</dd></dl>

<dl class="method">
<dt id="compile.Compiler.compile">
<code class="descname">compile</code><span class="sig-paren">(</span><em>node: DHParser.syntaxtree.Node</em><span class="sig-paren">)</span> &#x2192; Any<a class="reference internal" href="_modules/compile.html#Compiler.compile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#compile.Compiler.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the compilation method for the given node and returns the
result of the compilation.</p>
<p>The method’s name is derived from either the node’s parser
name or, if the parser is anonymous, the node’s parser’s class
name by adding the prefix <code class="docutils literal notranslate"><span class="pre">on_</span></code>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">compile</span></code> does not call any compilation functions
for the parsers of the sub nodes by itself. Rather, this should
be done within the compilation methods.</p>
</dd></dl>

<dl class="method">
<dt id="compile.Compiler.fallback_compiler">
<code class="descname">fallback_compiler</code><span class="sig-paren">(</span><em>node: DHParser.syntaxtree.Node</em><span class="sig-paren">)</span> &#x2192; Any<a class="reference internal" href="_modules/compile.html#Compiler.fallback_compiler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#compile.Compiler.fallback_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a generic compiler function which will be called on
all those node types for which no compiler method <cite>on_XXX</cite> has
been defined.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="compile.Compiler.method_name">
<em class="property">static </em><code class="descname">method_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/compile.html#Compiler.method_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#compile.Compiler.method_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the method name for <cite>node_name</cite>, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Compiler</span><span class="o">.</span><span class="n">method_name</span><span class="p">(</span><span class="s1">&#39;expression&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>‘on_expression’</p>
</dd></dl>

<dl class="staticmethod">
<dt id="compile.Compiler.propagate_error_flags">
<em class="property">static </em><code class="descname">propagate_error_flags</code><span class="sig-paren">(</span><em>lazy: bool = True</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/compile.html#Compiler.propagate_error_flags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#compile.Compiler.propagate_error_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagates error flags from children to parent nodes to make sure
that the parent’s error flag is always greater or equal the maximum
of the children’s error flags.</p>
</dd></dl>

<dl class="method">
<dt id="compile.Compiler.set_grammar_name">
<code class="descname">set_grammar_name</code><span class="sig-paren">(</span><em>grammar_name=''</em>, <em>grammar_source=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/compile.html#Compiler.set_grammar_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#compile.Compiler.set_grammar_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the grammar’s name and the grammar’s source.</p>
<p>The grammar name and the source text of the grammar are
metadata about the grammar that do not affect the compilation
process. Classes inheriting from <cite>Compiler</cite> can use this
information to name and annotate its output.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="compile.compile_source">
<code class="descname">compile_source</code><span class="sig-paren">(</span><em>source: str, preprocessor: Union[typing.Callable[[str], typing.Union[str, typing.Tuple[str, typing.Union[typing.Callable[[int], int], functools.partial]]]], functools.partial, NoneType], parser: DHParser.parse.Grammar, transformer: Union[typing.Callable[[DHParser.syntaxtree.Node], typing.Any], functools.partial], compiler: compile.Compiler</em><span class="sig-paren">)</span> &#x2192; Tuple[[Any, List[DHParser.error.Error]], DHParser.syntaxtree.Node]<a class="reference internal" href="_modules/compile.html#compile_source"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#compile.compile_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles a source in four stages:
1. Pre-Processing (if needed)
2. Parsing
3. AST-transformation
4. Compiling.</p>
<p>The compilations stage is only invoked if no errors occurred in
either of the two previous stages.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – The input text for compilation or a the name of a
file containing the input text.</li>
<li><strong>preprocessor</strong> (<em>function</em>) – text -&gt; text. A preprocessor function
or None, if no preprocessor is needed.</li>
<li><strong>parser</strong> (<em>function</em>) – A parsing function or grammar class</li>
<li><strong>transformer</strong> (<em>function</em>) – A transformation function that takes
the root-node of the concrete syntax tree as an argument and
transforms it (in place) into an abstract syntax tree.</li>
<li><strong>compiler</strong> (<em>function</em>) – A compiler function or compiler class
instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Returns (tuple):</dt>
<dd>The result of the compilation as a 3-tuple
(result, errors, abstract syntax tree). In detail:
1. The result as returned by the compiler or <code class="docutils literal notranslate"><span class="pre">None</span></code> in case of failure
2. A list of error or warning messages
3. The root-node of the abstract syntax tree</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-error">
<span id="module-error"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">error</span></code><a class="headerlink" href="#module-error" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">error</span></code> defines class Error and a few helpful functions that are
needed for error reporting of DHParser. Usually, what is of interest are
the string representations of the error objects. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">DHParser</span> <span class="k">import</span> <span class="n">compile_source</span><span class="p">,</span> <span class="n">has_errors</span>

<span class="n">result</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">ast</span> <span class="o">=</span> <span class="n">compile_source</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">preprocessor</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span>
                                     <span class="n">transformer</span><span class="p">,</span> <span class="n">compiler</span><span class="p">)</span>
<span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">has_errors</span><span class="p">(</span><span class="n">errors</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There have been fatal errors!&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There have been warnings, but no errors.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="error.is_error">
<code class="descname">is_error</code><span class="sig-paren">(</span><em>code: int</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/error.html#is_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#error.is_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True, if error is an error, not just a warning.</p>
</dd></dl>

<dl class="function">
<dt id="error.is_warning">
<code class="descname">is_warning</code><span class="sig-paren">(</span><em>code: int</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/error.html#is_warning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#error.is_warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True, if error is merely a warning.</p>
</dd></dl>

<dl class="function">
<dt id="error.has_errors">
<code class="descname">has_errors</code><span class="sig-paren">(</span><em>messages: Iterable[error.Error], level: int = 1000</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/error.html#has_errors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#error.has_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True, if at least one entry in <cite>messages</cite> has at
least the given error <cite>level</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="error.only_errors">
<code class="descname">only_errors</code><span class="sig-paren">(</span><em>messages: Iterable[error.Error], level: int = 1000</em><span class="sig-paren">)</span> &#x2192; Iterator[error.Error]<a class="reference internal" href="_modules/error.html#only_errors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#error.only_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an Iterator that yields only those messages that have
at least the given error level.</p>
</dd></dl>

<dl class="function">
<dt id="error.linebreaks">
<code class="descname">linebreaks</code><span class="sig-paren">(</span><em>text: Union[DHParser.stringview.StringView, str]</em><span class="sig-paren">)</span> &#x2192; List[int]<a class="reference internal" href="_modules/error.html#linebreaks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#error.linebreaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of indices all line breaks in the text.</p>
</dd></dl>

<dl class="function">
<dt id="error.line_col">
<code class="descname">line_col</code><span class="sig-paren">(</span><em>lbreaks: List[int], pos: int</em><span class="sig-paren">)</span> &#x2192; Tuple[int, int]<a class="reference internal" href="_modules/error.html#line_col"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#error.line_col" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position within a text as (line, column)-tuple based
on a list of all line breaks, including -1 and EOF.</p>
</dd></dl>

<dl class="function">
<dt id="error.adjust_error_locations">
<code class="descname">adjust_error_locations</code><span class="sig-paren">(</span><em>errors: List[error.Error], original_text: Union[DHParser.stringview.StringView, str], source_mapping: Union[typing.Callable[[int], int], functools.partial] = &lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span> &#x2192; List[error.Error]<a class="reference internal" href="_modules/error.html#adjust_error_locations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#error.adjust_error_locations" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds (or adjusts) line and column numbers of error messages in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>errors</strong> – The list of errors as returned by the method
<code class="docutils literal notranslate"><span class="pre">collect_errors()</span></code> of a Node object</li>
<li><strong>original_text</strong> – The source text on which the errors occurred.
(Needed in order to determine the line and column numbers.)</li>
<li><strong>source_mapping</strong> – A function that maps error positions to their
positions in the original source file.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The list of errors. (Returning the list of errors is just syntactical
sugar. Be aware that the line, col and orig_pos attributes have been
changed in place.)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="domain-specific-language-modules-reference">
<h2>Domain Specific Language Modules Reference<a class="headerlink" href="#domain-specific-language-modules-reference" title="Permalink to this headline">¶</a></h2>
<p>DHParser contains additional support for domain specific languages.
Module <code class="docutils literal notranslate"><span class="pre">ebnf</span></code> provides a self-hosting parser for EBNF-Grammars as
well as an EBNF-compiler that compiles an EBNF-Grammar into a
DHParser based Grammar class that can be executed to parse source text
conforming to this grammar into contrete syntax trees.</p>
<p>Module <code class="docutils literal notranslate"><span class="pre">dsl</span></code> contains additional functions to support the compilation
of arbitrary domain specific languages (DSL).</p>
<p>One very indispensable part of the systematic construction of domain
specific languages is testing. DHParser supports unit testing of
smaller as well as larger components of the Grammar of a DSL.</p>
<div class="section" id="module-ebnf">
<span id="module-ebnf"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">ebnf</span></code><a class="headerlink" href="#module-ebnf" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">ebnf</span></code> provides a self-hosting parser for EBNF-Grammars as
well as an EBNF-compiler that compiles an EBNF-Grammar into a
DHParser based Grammar class that can be executed to parse source text
conforming to this grammar into contrete syntax trees.</p>
<dl class="class">
<dt id="ebnf.EBNFGrammar">
<em class="property">class </em><code class="descname">EBNFGrammar</code><span class="sig-paren">(</span><em>root: DHParser.parse.Parser = None</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/ebnf.html#EBNFGrammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ebnf.EBNFGrammar" title="Permalink to this definition">¶</a></dt>
<dd><p>Parser for an EBNF source file, with this grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># EBNF-Grammar in EBNF

@ comment    =  /#.*(?:\n|$)/                # comments start with &#39;#&#39; and
                                             # eat all chars up to and including &#39;\n&#39;
@ whitespace =  /\s*/                        # whitespace includes linefeed
@ literalws  =  right                        # trailing whitespace of literals will be
                                             # ignored tacitly

syntax     =  [~//] { definition | directive } §EOF
definition =  symbol §&quot;=&quot; expression
directive  =  &quot;@&quot; §symbol &quot;=&quot; ( regexp | literal | list_ )

expression =  term { &quot;|&quot; term }
term       =  { [&quot;§&quot;] factor }+               # &quot;§&quot; means all following factors mandatory
factor     =  [flowmarker] [retrieveop] symbol !&quot;=&quot;   # negative lookahead to be sure
                                                      # it&#39;s not a definition
            | [flowmarker] literal
            | [flowmarker] regexp
            | [flowmarker] oneormore
            | [flowmarker] group
            | [flowmarker] unordered
            | repetition
            | option

flowmarker =  &quot;!&quot;  | &quot;&amp;&quot;                     # &#39;!&#39; negative lookahead, &#39;&amp;&#39; positive lookahead
            | &quot;-!&quot; | &quot;-&amp;&quot;                    # &#39;-&#39; negative lookbehind, &#39;-&amp;&#39; positive lookbehind
retrieveop =  &quot;::&quot; | &quot;:&quot;                     # &#39;::&#39; pop, &#39;:&#39; retrieve

group      =  &quot;(&quot; §expression &quot;)&quot;
unordered  =  &quot;&lt;&quot; §expression &quot;&gt;&quot;            # elements of expression in arbitrary order
oneormore  =  &quot;{&quot; expression &quot;}+&quot;
repetition =  &quot;{&quot; §expression &quot;}&quot;
option     =  &quot;[&quot; §expression &quot;]&quot;

symbol     =  /(?!\d)\w+/~                   # e.g. expression, factor, parameter_list
literal    =  /&quot;(?:[^&quot;]|\\&quot;)*?&quot;/~            # e.g. &quot;(&quot;, &#39;+&#39;, &#39;while&#39;
            | /&#39;(?:[^&#39;]|\\&#39;)*?&#39;/~            # whitespace following literals will be ignored
regexp     =  /~?\/(?:\\\/|[^\/])*?\/~?/~    # e.g. /\w+/, ~/#.*(?:\n|$)/~
                                             # &#39;~&#39; is a whitespace-marker, if present leading
                                             # or trailing whitespace of a regular expression
                                             # will be ignored tacitly.
list_      =  /\w+/~ { &quot;,&quot; /\w+/~ }          # comma separated list of symbols,
                                             # e.g. BEGIN_LIST, END_LIST,
                                             # BEGIN_QUOTE, END_QUOTE
                                             # see CommonMark/markdown.py for an exmaple
EOF =  !/./
</pre></div>
</div>
</dd></dl>

<dl class="exception">
<dt id="ebnf.EBNFCompilerError">
<em class="property">exception </em><code class="descname">EBNFCompilerError</code><a class="reference internal" href="_modules/ebnf.html#EBNFCompilerError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ebnf.EBNFCompilerError" title="Permalink to this definition">¶</a></dt>
<dd><p>Error raised by <cite>EBNFCompiler</cite> class. (Not compilation errors
in the strict sense, see <cite>CompilationError</cite> in module <code class="docutils literal notranslate"><span class="pre">dsl.py</span></code>)</p>
</dd></dl>

<dl class="class">
<dt id="ebnf.EBNFCompiler">
<em class="property">class </em><code class="descname">EBNFCompiler</code><span class="sig-paren">(</span><em>grammar_name=''</em>, <em>grammar_source=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ebnf.html#EBNFCompiler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ebnf.EBNFCompiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a Parser from an abstract syntax tree of a grammar specified
in EBNF-Notation.</p>
<p>Instances of this class must be called with the root-node of the
abstract syntax tree from an EBNF-specification of a formal language.
The returned value is the Python-source-code of a Grammar class for
this language that can be used to parse texts in this language.
See classes <cite>parser.Compiler</cite> and <cite>parser.Grammar</cite> for more information.</p>
<p>Addionally, class EBNFCompiler provides helper methods to generate
code-skeletons for a preprocessor, AST-transformation and full
compilation of the formal language. These method’s names start with
the prefix <cite>gen_</cite>.</p>
<dl class="attribute">
<dt id="ebnf.EBNFCompiler.current_symbols">
<code class="descname">current_symbols</code><a class="headerlink" href="#ebnf.EBNFCompiler.current_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>During compilation, a list containing the root
node of the currently compiled definition as first element
and then the nodes of the symbols that are referred to in
the currently compiled definition.</p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.EBNFCompiler.rules">
<code class="descname">rules</code><a class="headerlink" href="#ebnf.EBNFCompiler.rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary that maps rule names to a list of Nodes that
contain symbol-references in the definition of the rule.
The first item in the list is the node of the rule-
definition itself. Example:</p>
<blockquote>
<div><cite>alternative = a | b</cite></div></blockquote>
<p>Now <cite>[node.content for node in self.rules[‘alternative’]]</cite>
yields <cite>[‘alternative = a | b’, ‘a’, ‘b’]</cite></p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.EBNFCompiler.symbols">
<code class="descname">symbols</code><a class="headerlink" href="#ebnf.EBNFCompiler.symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of symbol names to their first usage (not
their definition!) in the EBNF source.</p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.EBNFCompiler.variables">
<code class="descname">variables</code><a class="headerlink" href="#ebnf.EBNFCompiler.variables" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of symbols names that are used with the
Pop or Retrieve operator. Because the values of these
symbols need to be captured they are called variables.
See <cite>test_parser.TestPopRetrieve</cite> for an example.</p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.EBNFCompiler.recursive">
<code class="descname">recursive</code><a class="headerlink" href="#ebnf.EBNFCompiler.recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of symbols that are used recursively and
therefore require a <cite>Forward</cite>-operator.</p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.EBNFCompiler.definitions">
<code class="descname">definitions</code><a class="headerlink" href="#ebnf.EBNFCompiler.definitions" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary of definitions. Other than <cite>rules</cite>
this maps the symbols to their compiled definienda.</p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.EBNFCompiler.deferred_taks">
<code class="descname">deferred_taks</code><a class="headerlink" href="#ebnf.EBNFCompiler.deferred_taks" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of callables that is filled during
compilatation, but that will be executed only after
compilation has finished. Typically, it contains
sementatic checks that require information that
is only available upon completion of compilation.</p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.EBNFCompiler.root">
<code class="descname">root</code><a class="headerlink" href="#ebnf.EBNFCompiler.root" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the root symbol.</p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.EBNFCompiler.directives">
<code class="descname">directives</code><a class="headerlink" href="#ebnf.EBNFCompiler.directives" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary of all directives and their default
values.</p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.EBNFCompiler.re_flags">
<code class="descname">re_flags</code><a class="headerlink" href="#ebnf.EBNFCompiler.re_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of regular expression flags to be added to all
regular expressions found in the current parsing process</p>
</dd></dl>

<dl class="method">
<dt id="ebnf.EBNFCompiler.assemble_parser">
<code class="descname">assemble_parser</code><span class="sig-paren">(</span><em>definitions: List[Tuple[str, str]], root_node: DHParser.syntaxtree.Node</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/ebnf.html#EBNFCompiler.assemble_parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ebnf.EBNFCompiler.assemble_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the Python code for the parser after compilation of
the EBNF-Grammar</p>
</dd></dl>

<dl class="method">
<dt id="ebnf.EBNFCompiler.gen_compiler_skeleton">
<code class="descname">gen_compiler_skeleton</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/ebnf.html#EBNFCompiler.gen_compiler_skeleton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ebnf.EBNFCompiler.gen_compiler_skeleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Python-skeleton-code for a Compiler-class for the
previously compiled formal language.</p>
</dd></dl>

<dl class="method">
<dt id="ebnf.EBNFCompiler.gen_preprocessor_skeleton">
<code class="descname">gen_preprocessor_skeleton</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/ebnf.html#EBNFCompiler.gen_preprocessor_skeleton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ebnf.EBNFCompiler.gen_preprocessor_skeleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Python-skeleton-code for a preprocessor-function for
the previously compiled formal language.</p>
</dd></dl>

<dl class="method">
<dt id="ebnf.EBNFCompiler.gen_transformer_skeleton">
<code class="descname">gen_transformer_skeleton</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/ebnf.html#EBNFCompiler.gen_transformer_skeleton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ebnf.EBNFCompiler.gen_transformer_skeleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Python-skeleton-code for the AST-transformation for the
previously compiled formal language.</p>
</dd></dl>

<dl class="method">
<dt id="ebnf.EBNFCompiler.non_terminal">
<code class="descname">non_terminal</code><span class="sig-paren">(</span><em>node: DHParser.syntaxtree.Node</em>, <em>parser_class: str</em>, <em>custom_args: List[str] = []</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/ebnf.html#EBNFCompiler.non_terminal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ebnf.EBNFCompiler.non_terminal" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles any non-terminal, where <cite>parser_class</cite> indicates the Parser class
name for the particular non-terminal.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ebnf.grammar_changed">
<code class="descname">grammar_changed</code><span class="sig-paren">(</span><em>grammar_class</em>, <em>grammar_source: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/ebnf.html#grammar_changed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ebnf.grammar_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">grammar_class</span></code> does not reflect the latest
changes of <code class="docutils literal notranslate"><span class="pre">grammar_source</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>grammar_class</strong> – the parser class representing the grammar
or the file name of a compiler suite containing the grammar</li>
<li><strong>grammar_source</strong> – File name or string representation of the
EBNF code of the grammar</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Returns (bool):</dt>
<dd>True, if the source text of the grammar is different from the
source from which the grammar class was generated</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.PreprocessorFactoryFunc">
<code class="descname">PreprocessorFactoryFunc</code><a class="headerlink" href="#ebnf.PreprocessorFactoryFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Callable</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.ParserFactoryFunc">
<code class="descname">ParserFactoryFunc</code><a class="headerlink" href="#ebnf.ParserFactoryFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Callable</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.TransformerFactoryFunc">
<code class="descname">TransformerFactoryFunc</code><a class="headerlink" href="#ebnf.TransformerFactoryFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Callable</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ebnf.CompilerFactoryFunc">
<code class="descname">CompilerFactoryFunc</code><a class="headerlink" href="#ebnf.CompilerFactoryFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Callable</span></code></p>
</dd></dl>

</div>
<div class="section" id="module-dsl">
<span id="module-dsl"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">dsl</span></code><a class="headerlink" href="#module-dsl" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">dsl</span></code> contains various functions to support the
compilation of domain specific languages based on an EBNF-grammar.</p>
<dl class="exception">
<dt id="dsl.GrammarError">
<em class="property">exception </em><code class="descname">GrammarError</code><span class="sig-paren">(</span><em>errors</em>, <em>grammar_src</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dsl.html#GrammarError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dsl.GrammarError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when (already) the grammar of a domain specific language (DSL)
contains errors.</p>
</dd></dl>

<dl class="exception">
<dt id="dsl.CompilationError">
<em class="property">exception </em><code class="descname">CompilationError</code><span class="sig-paren">(</span><em>errors</em>, <em>dsl_text</em>, <em>dsl_grammar</em>, <em>AST</em>, <em>result</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dsl.html#CompilationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dsl.CompilationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when a string or file in a domain specific language (DSL)
contains errors.</p>
</dd></dl>

<dl class="function">
<dt id="dsl.load_compiler_suite">
<code class="descname">load_compiler_suite</code><span class="sig-paren">(</span><em>compiler_suite: str</em><span class="sig-paren">)</span> &#x2192; Tuple[[Callable[Union[typing.Callable[[str], typing.Union[str, typing.Tuple[str, typing.Union[typing.Callable[[int], int], functools.partial]]]], functools.partial]], Callable[DHParser.parse.Grammar], Callable[Union[typing.Callable[[DHParser.syntaxtree.Node], typing.Any], functools.partial]]], Callable[DHParser.compile.Compiler]]<a class="reference internal" href="_modules/dsl.html#load_compiler_suite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dsl.load_compiler_suite" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts a compiler suite from file or string <cite>compiler_suite</cite>
and returns it as a tuple (preprocessor, parser, ast, compiler).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">4-tuple (preprocessor function, parser class, ast transformer function, compiler class)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="dsl.compileDSL">
<code class="descname">compileDSL</code><span class="sig-paren">(</span><em>text_or_file: str, preprocessor: Union[typing.Callable[[str], typing.Union[str, typing.Tuple[str, typing.Union[typing.Callable[[int], int], functools.partial]]]], functools.partial], dsl_grammar: Union[str, DHParser.parse.Grammar], ast_transformation: Union[typing.Callable[[DHParser.syntaxtree.Node], typing.Any], functools.partial], compiler: DHParser.compile.Compiler</em><span class="sig-paren">)</span> &#x2192; Any<a class="reference internal" href="_modules/dsl.html#compileDSL"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dsl.compileDSL" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles a text in a domain specific language (DSL) with an
EBNF-specified grammar. Returns the compiled text or raises a
compilation error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">CompilationError if any errors occurred during compilation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="dsl.raw_compileEBNF">
<code class="descname">raw_compileEBNF</code><span class="sig-paren">(</span><em>ebnf_src: str</em>, <em>branding='DSL'</em><span class="sig-paren">)</span> &#x2192; DHParser.ebnf.EBNFCompiler<a class="reference internal" href="_modules/dsl.html#raw_compileEBNF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dsl.raw_compileEBNF" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles an EBNF grammar file and returns the compiler object
that was used and which can now be queried for the result as well
as skeleton code for preprocessor, transformer and compiler objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ebnf_src</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – Either the file name of an EBNF grammar or
the EBNF grammar itself as a string.</li>
<li><strong>branding</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – Branding name for the compiler suite source
code.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An instance of class <code class="docutils literal notranslate"><span class="pre">ebnf.EBNFCompiler</span></code></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">CompilationError if any errors occurred during compilation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="dsl.compileEBNF">
<code class="descname">compileEBNF</code><span class="sig-paren">(</span><em>ebnf_src: str</em>, <em>branding='DSL'</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/dsl.html#compileEBNF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dsl.compileEBNF" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles an EBNF source file and returns the source code of a
compiler suite with skeletons for preprocessor, transformer and
compiler.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ebnf_src</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – Either the file name of an EBNF grammar or
the EBNF grammar itself as a string.</li>
<li><strong>branding</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – Branding name for the compiler suite source
code.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The complete compiler suite skeleton as Python source code.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">CompilationError if any errors occurred during compilation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="dsl.grammar_provider">
<code class="descname">grammar_provider</code><span class="sig-paren">(</span><em>ebnf_src: str</em>, <em>branding='DSL'</em><span class="sig-paren">)</span> &#x2192; DHParser.parse.Grammar<a class="reference internal" href="_modules/dsl.html#grammar_provider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dsl.grammar_provider" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles an EBNF grammar and returns a grammar-parser provider
function for that grammar.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ebnf_src</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – Either the file name of an EBNF grammar or
the EBNF grammar itself as a string.</li>
<li><strong>branding</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a>) – Branding name for the compiler
suite source code.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A provider function for a grammar object for texts in the
language defined by <code class="docutils literal notranslate"><span class="pre">ebnf_src</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="dsl.compile_on_disk">
<code class="descname">compile_on_disk</code><span class="sig-paren">(</span><em>source_file: str</em>, <em>compiler_suite=''</em>, <em>extension='.xml'</em><span class="sig-paren">)</span> &#x2192; Iterable[DHParser.error.Error]<a class="reference internal" href="_modules/dsl.html#compile_on_disk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dsl.compile_on_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles the a source file with a given compiler and writes the
result to a file.</p>
<p>If no <code class="docutils literal notranslate"><span class="pre">compiler_suite</span></code> is given it is assumed that the source
file is an EBNF grammar. In this case the result will be a Python
script containing a parser for that grammar as well as the
skeletons for a preprocessor, AST transformation table, and compiler.
If the Python script already exists only the parser name in the
script will be updated. (For this to work, the different names
need to be delimited section marker blocks.). <cite>compile_on_disk()</cite>
returns a list of error messages or an empty list if no errors
occurred.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_file</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – The file name of the source text to be
compiled.</li>
<li><strong>compiler_suite</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – The file name of the compiler suite
(usually ending with ‘Compiler.py’), with which the source
file shall be compiled. If this is left empty, the source
file is assumed to be an EBNF-Grammar that will be compiled
with the internal EBNF-Compiler.</li>
<li><strong>extension</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – The result of the compilation (if successful)
is written to a file with the same name but a different
extension than the source file. This parameter sets the
extension.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A (potentially empty) list of error or warning messages.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="dsl.recompile_grammar">
<code class="descname">recompile_grammar</code><span class="sig-paren">(</span><em>ebnf_filename</em>, <em>force=False</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/dsl.html#recompile_grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dsl.recompile_grammar" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-compiles an EBNF-grammar if necessary, that is, if either no
corresponding ‘XXXXCompiler.py’-file exists or if that file is
outdated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ebnf_filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – The filename of the ebnf-source of the
grammar. In case this is a directory and not a file, all
files within this directory ending with .ebnf will be
compiled.</li>
<li><strong>force</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a>) – If False (default), the grammar will only be
recompiled if it has been changed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-testing">
<span id="module-testing"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">testing</span></code><a class="headerlink" href="#module-testing" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">testing</span></code> contains support for unit-testing domain specific
languages. Tests for arbitrarily small components of the Grammar can
be written into test files with ini-file syntax in order to test
whether the parser matches or fails as expected. It can also be
tested whether it produces an expected concrete or abstract syntax tree.
Usually, however, unexpected failure to match a certain string is the
main cause of trouble when constructing a context free Grammar.</p>
<dl class="function">
<dt id="testing.unit_from_configfile">
<code class="descname">unit_from_configfile</code><span class="sig-paren">(</span><em>config_filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/testing.html#unit_from_configfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#testing.unit_from_configfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads grammar unit tests contained in a file in config file (.ini)
syntax.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config_filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – A config file containing Grammar unit-tests</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dictionary representing the unit tests.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="testing.unit_from_json">
<code class="descname">unit_from_json</code><span class="sig-paren">(</span><em>json_filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/testing.html#unit_from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#testing.unit_from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads grammar unit tests from a json file.</p>
</dd></dl>

<dl class="function">
<dt id="testing.unit_from_file">
<code class="descname">unit_from_file</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/testing.html#unit_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#testing.unit_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a grammar unit test from a file. The format of the file is
determined by the ending of its name.</p>
</dd></dl>

<dl class="function">
<dt id="testing.get_report">
<code class="descname">get_report</code><span class="sig-paren">(</span><em>test_unit</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/testing.html#get_report"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#testing.get_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a text-report of the results of a grammar unit test. The report
lists the source of all tests as well as the error messages, if a test
failed or the abstract-syntax-tree (AST) in case of success.</p>
<p>If an asterix has been appended to the test name then the concrete syntax
tree will also be added to the report in this particular case.</p>
<p>The purpose of the latter is to help constructing and debugging
of AST-Transformations. It is better to switch the CST-output on and off
with the asterix marker when needed than to output the CST for all tests
which would unneccesarily bloat the test reports.</p>
</dd></dl>

<dl class="function">
<dt id="testing.grammar_unit">
<code class="descname">grammar_unit</code><span class="sig-paren">(</span><em>test_unit</em>, <em>parser_factory</em>, <em>transformer_factory</em>, <em>report=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/testing.html#grammar_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#testing.grammar_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit tests for a grammar-parser and ast transformations.</p>
</dd></dl>

<dl class="function">
<dt id="testing.grammar_suite">
<code class="descname">grammar_suite</code><span class="sig-paren">(</span><em>directory, parser_factory, transformer_factory, fn_patterns=['*test*'], ignore_unknown_filetypes=False, report=True, verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/testing.html#grammar_suite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#testing.grammar_suite" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs all grammar unit tests in a directory. A file is considered a test
unit, if it has the word “test” in its name.</p>
</dd></dl>

<dl class="function">
<dt id="testing.reset_unit">
<code class="descname">reset_unit</code><span class="sig-paren">(</span><em>test_unit</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/testing.html#reset_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#testing.reset_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the tests in <code class="docutils literal notranslate"><span class="pre">test_unit</span></code> by removing all results and
error messages.</p>
</dd></dl>

<dl class="function">
<dt id="testing.runner">
<code class="descname">runner</code><span class="sig-paren">(</span><em>test_classes</em>, <em>namespace</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/testing.html#runner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#testing.runner" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs all or some selected Python unit tests found in the
namespace. To run all tests in a module, call
<code class="docutils literal notranslate"><span class="pre">runner(&quot;&quot;,</span> <span class="pre">globals())</span></code> from within that module.</p>
<p>Unit-Tests are either classes, the name of which starts with
“Test” and methods, the name of which starts with “test” contained
in such classes or functions, the name of which starts with “test”.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tests</strong> – Either a string or a list of strings that contains the
names of test or test classes. Each test and, in the case
of a test class, all tests within the test class will be
run.</li>
<li><strong>namespace</strong> – The namespace for running the test, usually
<code class="docutils literal notranslate"><span class="pre">globals()</span></code> should be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<dl class="docutils">
<dt>class TestSomething()</dt>
<dd><dl class="first last docutils">
<dt>def setup(self):</dt>
<dd>pass</dd>
<dt>def teardown(self):</dt>
<dd>pass</dd>
<dt>def test_something(self):</dt>
<dd>pass</dd>
</dl>
</dd>
<dt>if __name__ == “__main__”:</dt>
<dd>from DHParser.testing import runner
runner(“”, globals())</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="supporting-modules-reference">
<h2>Supporting Modules Reference<a class="headerlink" href="#supporting-modules-reference" title="Permalink to this headline">¶</a></h2>
<p>Finally, DHParser comprises a number of “toolkit”-modules which
define helpful functions and classes that will are used at different
places throughout the other DHParser-modules.</p>
<div class="section" id="module-toolkit">
<span id="module-toolkit"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">toolkit</span></code><a class="headerlink" href="#module-toolkit" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">toolkit</span></code> contains utility functions that are needed across
several of the the other DHParser-Modules or that are just very generic
so that they are best defined in a toolkit-module.</p>
<dl class="function">
<dt id="toolkit.escape_re">
<code class="descname">escape_re</code><span class="sig-paren">(</span><em>strg: str</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/toolkit.html#escape_re"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.escape_re" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the string with all regular expression special characters escaped.</p>
</dd></dl>

<dl class="function">
<dt id="toolkit.escape_control_characters">
<code class="descname">escape_control_characters</code><span class="sig-paren">(</span><em>strg: str</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/toolkit.html#escape_control_characters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.escape_control_characters" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Replace all control characters (e.g.</dt>
<dd>) in a string by their backslashed representation.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="toolkit.is_filename">
<code class="descname">is_filename</code><span class="sig-paren">(</span><em>strg: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/toolkit.html#is_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.is_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to guess whether string <code class="docutils literal notranslate"><span class="pre">s</span></code> is a file name.</p>
</dd></dl>

<dl class="function">
<dt id="toolkit.lstrip_docstring">
<code class="descname">lstrip_docstring</code><span class="sig-paren">(</span><em>docstring: str</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/toolkit.html#lstrip_docstring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.lstrip_docstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Strips leading whitespace from a docstring.</p>
</dd></dl>

<dl class="function">
<dt id="toolkit.load_if_file">
<code class="descname">load_if_file</code><span class="sig-paren">(</span><em>text_or_file</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/toolkit.html#load_if_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.load_if_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads and returns content of a text-file if parameter
<cite>text_or_file</cite> is a file name (i.e. a single line string),
otherwise (i.e. if <cite>text_or_file</cite> is a multi-line string)
<cite>text_or_file</cite> is returned.</p>
</dd></dl>

<dl class="function">
<dt id="toolkit.is_python_code">
<code class="descname">is_python_code</code><span class="sig-paren">(</span><em>text_or_file: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/toolkit.html#is_python_code"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.is_python_code" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether ‘text_or_file’ is python code or the name of a file that
contains python code.</p>
</dd></dl>

<dl class="function">
<dt id="toolkit.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><em>*txt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/toolkit.html#md5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the md5-checksum for <cite>txt</cite>. This can be used to test if
some piece of text, for example a grammar source file, has changed.</p>
</dd></dl>

<dl class="function">
<dt id="toolkit.expand_table">
<code class="descname">expand_table</code><span class="sig-paren">(</span><em>compact_table: Dict</em><span class="sig-paren">)</span> &#x2192; Dict<a class="reference internal" href="_modules/toolkit.html#expand_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.expand_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Expands a table by separating keywords that are tuples or strings
containing comma separated words into single keyword entries with
the same values. Returns the expanded table.
Example:
&gt;&gt;&gt; expand_table({“a, b”: 1, (‘d’,’e’,’f’):5, “c”:3})
{‘a’: 1, ‘b’: 1, ‘d’: 5, ‘e’: 5, ‘f’: 5, ‘c’: 3}</p>
</dd></dl>

<dl class="function">
<dt id="toolkit.compile_python_object">
<code class="descname">compile_python_object</code><span class="sig-paren">(</span><em>python_src</em>, <em>catch_obj_regex=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/toolkit.html#compile_python_object"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.compile_python_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles the python source code and returns the (first) object
the name of which is matched by <code class="docutils literal notranslate"><span class="pre">catch_obj_regex</span></code>. If catch_obj
is the empty string, the namespace dictionary will be returned.</p>
</dd></dl>

<dl class="function">
<dt id="toolkit.smart_list">
<code class="descname">smart_list</code><span class="sig-paren">(</span><em>arg: Union[typing.Iterable, typing.Any]</em><span class="sig-paren">)</span> &#x2192; Union[typing.Sequence, typing.Set]<a class="reference internal" href="_modules/toolkit.html#smart_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.smart_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the argument as list, depending on its type and content.</p>
<p>If the argument is a string, it will be interpreted as a list of
comma separated values, trying ‘;’, ‘,’, ‘ ‘ as possible delimiters
in this order, e.g.
&gt;&gt;&gt; smart_list(‘1; 2, 3; 4’)
[‘1’, ‘2, 3’, ‘4’]
&gt;&gt;&gt; smart_list(‘2, 3’)
[‘2’, ‘3’]
&gt;&gt;&gt; smart_list(‘a b cd’)
[‘a’, ‘b’, ‘cd’]</p>
<p>If the argument is a collection other than a string, it will be
returned as is, e.g.
&gt;&gt;&gt; smart_list((1, 2, 3))
(1, 2, 3)
&gt;&gt;&gt; smart_list({1, 2, 3})
{1, 2, 3}</p>
<p>If the argument is another iterable than a collection, it will
be converted into a list, e.g.
&gt;&gt;&gt; smart_list(i for i in {1,2,3})
[1, 2, 3]</p>
<p>Finally, if none of the above is true, the argument will be
wrapped in a list and returned, e.g.
&gt;&gt;&gt; smart_list(125)
[125]</p>
</dd></dl>

<dl class="function">
<dt id="toolkit.sane_parser_name">
<code class="descname">sane_parser_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/toolkit.html#sane_parser_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#toolkit.sane_parser_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether given name is an acceptable parser name. Parser names
must not be preceded or succeeded by a double underscore ‘__’!</p>
</dd></dl>

</div>
<div class="section" id="module-log">
<span id="module-log"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">log</span></code><a class="headerlink" href="#module-log" title="Permalink to this headline">¶</a></h3>
<p>Module <code class="docutils literal notranslate"><span class="pre">log</span></code> contains logging and debugging support for the
parsing process.</p>
<p>For logging functionality, the global variable LOGGING is defined which
contains the name of a directory where log files shall be placed. By
setting its value to the empty string “” logging can be turned off.</p>
<p>To read the directory name function <code class="docutils literal notranslate"><span class="pre">LOGS_DIR()</span></code> should be called
rather than reading the variable LOGGING. <code class="docutils literal notranslate"><span class="pre">LOGS_DIR()</span></code> makes sure
the directory exists and raises an error if a file with the same name
already exists.</p>
<p>For debugging of the parsing process, the parsing history can be
logged and written to an html-File.</p>
<p>For ease of use module <code class="docutils literal notranslate"><span class="pre">log</span></code> defines a context-manager <code class="docutils literal notranslate"><span class="pre">logging</span></code>
to which either <code class="docutils literal notranslate"><span class="pre">False</span></code> (turn off logging), a log directory name or
<code class="docutils literal notranslate"><span class="pre">True</span></code> for the default logging directory is passed as argument.
The other components of DHParser check whether logging is on and
write log files in the the logging directory accordingly. Usually,
this will be concrete and abstract syntax trees as well as the full
and abreviated parsing history.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">DHParser</span> <span class="k">import</span> <span class="n">compile_source</span><span class="p">,</span> <span class="n">logging</span>

<span class="k">with</span> <span class="n">logging</span><span class="p">(</span><span class="s2">&quot;LOGS&quot;</span><span class="p">):</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">ast</span> <span class="o">=</span> <span class="n">compile_source</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">preprocessor</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span>
                                         <span class="n">transformer</span><span class="p">,</span> <span class="n">compiler</span><span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="log.log_dir">
<code class="descname">log_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/log.html#log_dir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.log_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a directory for log files (if it does not exist) and
returns its path.</p>
<p>WARNING: Any files in the log dir will eventually be overwritten.
Don’t use a directory name that could be the name of a directory
for other purposes than logging.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">name of the logging directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="log.logging">
<code class="descname">logging</code><span class="sig-paren">(</span><em>dirname='LOGS'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/log.html#logging"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.logging" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager. Log files within this context will be stored in
directory <code class="docutils literal notranslate"><span class="pre">dirname</span></code>. Logging is turned off if name is empty.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dirname</strong> – the name for the log directory or the empty string to
turn logging of</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="log.is_logging">
<code class="descname">is_logging</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/log.html#is_logging"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.is_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>-&gt; True, if logging is turned on.</p>
</dd></dl>

<dl class="function">
<dt id="log.logfile_basename">
<code class="descname">logfile_basename</code><span class="sig-paren">(</span><em>filename_or_text</em>, <em>function_or_class_or_instance</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/log.html#logfile_basename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.logfile_basename" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a reasonable logfile-name (without extension) based on
the given information.</p>
</dd></dl>

<dl class="function">
<dt id="log.clear_logs">
<code class="descname">clear_logs</code><span class="sig-paren">(</span><em>logfile_types=frozenset({'.log'</em>, <em>'.ast'</em>, <em>'.cst'})</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/log.html#clear_logs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.clear_logs" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all logs from the log-directory and removes the
log-directory if it is empty.</p>
</dd></dl>

<dl class="class">
<dt id="log.HistoryRecord">
<em class="property">class </em><code class="descname">HistoryRecord</code><span class="sig-paren">(</span><em>call_stack: List[_ForwardRef('Parser')], node: DHParser.syntaxtree.Node, text: DHParser.stringview.StringView</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/log.html#HistoryRecord"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.HistoryRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores debugging information about one completed step in the
parsing history.</p>
<p>A parsing step is “completed” when the last one of a nested
sequence of parser-calls returns. The call stack including
the last parser call will be frozen in the <code class="docutils literal notranslate"><span class="pre">HistoryRecord</span></code>-
object. In addition a reference to the generated leaf node
(if any) will be stored and the result status of the last
parser call, which ist either MATCH, FAIL (i.e. no match)
or ERROR.</p>
<dl class="class">
<dt id="log.HistoryRecord.Snapshot">
<em class="property">class </em><code class="descname">Snapshot</code><span class="sig-paren">(</span><em>line</em>, <em>column</em>, <em>stack</em>, <em>status</em>, <em>text</em><span class="sig-paren">)</span><a class="headerlink" href="#log.HistoryRecord.Snapshot" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="log.HistoryRecord.Snapshot.column">
<code class="descname">column</code><a class="headerlink" href="#log.HistoryRecord.Snapshot.column" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="log.HistoryRecord.Snapshot.line">
<code class="descname">line</code><a class="headerlink" href="#log.HistoryRecord.Snapshot.line" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="log.HistoryRecord.Snapshot.stack">
<code class="descname">stack</code><a class="headerlink" href="#log.HistoryRecord.Snapshot.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="attribute">
<dt id="log.HistoryRecord.Snapshot.status">
<code class="descname">status</code><a class="headerlink" href="#log.HistoryRecord.Snapshot.status" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="attribute">
<dt id="log.HistoryRecord.Snapshot.text">
<code class="descname">text</code><a class="headerlink" href="#log.HistoryRecord.Snapshot.text" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="log.HistoryRecord.as_csv_line">
<code class="descname">as_csv_line</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/log.html#HistoryRecord.as_csv_line"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.HistoryRecord.as_csv_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns history record formatted as a csv table row.</p>
</dd></dl>

<dl class="method">
<dt id="log.HistoryRecord.as_html_tr">
<code class="descname">as_html_tr</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/log.html#HistoryRecord.as_html_tr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.HistoryRecord.as_html_tr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns history record formatted as an html table row.</p>
</dd></dl>

<dl class="method">
<dt id="log.HistoryRecord.as_tuple">
<code class="descname">as_tuple</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; log.Snapshot<a class="reference internal" href="_modules/log.html#HistoryRecord.as_tuple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.HistoryRecord.as_tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns history record formatted as a snapshot tuple.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="log.HistoryRecord.last_match">
<em class="property">static </em><code class="descname">last_match</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Union[_ForwardRef('HistoryRecord'), NoneType]<a class="reference internal" href="_modules/log.html#HistoryRecord.last_match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.HistoryRecord.last_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last match from the parsing-history.
:param history: the parsing-history as a list of HistoryRecord objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the history record of the last match or none if either history is
empty or no parser could match</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="log.HistoryRecord.most_advanced_match">
<em class="property">static </em><code class="descname">most_advanced_match</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Union[_ForwardRef('HistoryRecord'), NoneType]<a class="reference internal" href="_modules/log.html#HistoryRecord.most_advanced_match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.HistoryRecord.most_advanced_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the closest-to-the-end-match from the parsing-history.
:param history: the parsing-history as a list of HistoryRecord objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the history record of the closest-to-the-end-match or none if either history is
empty or no parser could match</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="log.log_ST">
<code class="descname">log_ST</code><span class="sig-paren">(</span><em>syntax_tree</em>, <em>log_file_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/log.html#log_ST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.log_ST" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an S-expression-representation of the <cite>syntax_tree</cite> to a file,
if logging is turned on.</p>
</dd></dl>

<dl class="function">
<dt id="log.log_parsing_history">
<code class="descname">log_parsing_history</code><span class="sig-paren">(</span><em>grammar</em>, <em>log_file_name: str = ''</em>, <em>html: bool = False</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/log.html#log_parsing_history"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#log.log_parsing_history" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a log of the parsing history of the most recently parsed document.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>grammar</strong> (<a class="reference internal" href="#parse.Grammar" title="parse.Grammar"><em>Grammar</em></a>) – The Grammar object from which the parsing history
shall be logged.</li>
<li><strong>log_file_name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a>) – The (base-)name of the log file to be written.
If no name is given (default), then the class name of the grammar
object will be used.</li>
<li><strong>html</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a>) – If true (default), the log will be output as html-Table,
otherwise as plain test. (Browsers might take a few seconds or
minutes to display the table for long histories.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-stringview">
<span id="module-stringview"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">stringview</span></code><a class="headerlink" href="#module-stringview" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>stringview.py - a string class where slices are views not copies as</dt>
<dd><blockquote class="first">
<div>with the standard Python strings.</div></blockquote>
<dl class="last docutils">
<dt>stringview.pxd - declarations for the cython Python to C compiler</dt>
<dd>to speed up handling of StringViews.</dd>
</dl>
</dd>
<dt>Copyright 2016  by Eckhart Arnold (<a class="reference external" href="mailto:arnold&#37;&#52;&#48;badw&#46;de">arnold<span>&#64;</span>badw<span>&#46;</span>de</a>)</dt>
<dd>Bavarian Academy of Sciences an Humanities (badw.de)</dd>
</dl>
<p>Licensed under the Apache License, Version 2.0 (the “License”);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<blockquote>
<div><a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></div></blockquote>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an “AS IS” BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied.  See the License for the specific language governing
permissions and limitations under the License.</p>
<p>StringView provides string-slicing without copying.
Slicing Python-strings always yields copies of a segment of the original
string. See: <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2008-May/079699.html">https://mail.python.org/pipermail/python-dev/2008-May/079699.html</a>
However, this becomes costly (in terms of space and as a consequence also
time) when parsing longer documents. Unfortunately, Python’s <cite>memoryview</cite>
does not work for unicode strings. Hence, the StringView class.</p>
<dl class="class">
<dt id="stringview.StringView">
<em class="property">class </em><code class="descname">StringView</code><a class="headerlink" href="#stringview.StringView" title="Permalink to this definition">¶</a></dt>
<dd><p>A rudimentary StringView class, just enough for the use cases
in parse.py. The difference between a StringView and the python
builtin strings is that StringView-objects do slicing without
copying, i.e. slices are just a view on a section of the sliced
string.</p>
<dl class="method">
<dt id="stringview.StringView.count">
<code class="descname">count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of non-overlapping occurrences of substring
<cite>sub</cite> in StringView S[start:end].  Optional arguments start and end
are interpreted as in slice notation.</p>
</dd></dl>

<dl class="method">
<dt id="stringview.StringView.find">
<code class="descname">find</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the lowest index in S where substring <cite>sub</cite> is found,
such that <cite>sub</cite> is contained within S[start:end].  Optional
arguments <cite>start</cite> and <cite>end</cite> are interpreted as in slice notation.
Returns -1 on failure.</p>
</dd></dl>

<dl class="method">
<dt id="stringview.StringView.index">
<code class="descname">index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an index for a string watched by a StringView object
to an index relative to the string view object, e.g.:
&gt;&gt;&gt; import re
&gt;&gt;&gt; sv = StringView(‘xxIxx’)[2:3]
&gt;&gt;&gt; match = sv.match(re.compile(‘I’))
&gt;&gt;&gt; match.end()
3
&gt;&gt;&gt; sv.index(match.end())
1</p>
</dd></dl>

<dl class="method">
<dt id="stringview.StringView.indices">
<code class="descname">indices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts indices for a string watched by a StringView object
to indices relative to the string view object. See also: <cite>sv_index()</cite></p>
</dd></dl>

<dl class="method">
<dt id="stringview.StringView.match">
<code class="descname">match</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes <cite>regex.match</cite> on the StringView object and returns the
result, which is either a match-object or None.</p>
</dd></dl>

<dl class="method">
<dt id="stringview.StringView.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string where <cite>old</cite> is replaced by <cite>new</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="stringview.StringView.rfind">
<code class="descname">rfind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.rfind" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the highest index in S where substring <cite>sub</cite> is found,
such that <cite>sub</cite> is contained within S[start:end].  Optional
arguments <cite>start</cite> and <cite>end</cite> are interpreted as in slice notation.
Returns -1 on failure.</p>
</dd></dl>

<dl class="method">
<dt id="stringview.StringView.search">
<code class="descname">search</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes regex.search on the StringView object and returns the
result, which is either a match-object or None.</p>
</dd></dl>

<dl class="method">
<dt id="stringview.StringView.split">
<code class="descname">split</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the words in <cite>self</cite>, using <cite>sep</cite> as the
delimiter string.  If <cite>sep</cite> is not specified or is None, any
whitespace string is a separator and empty strings are
removed from the result.</p>
</dd></dl>

<dl class="method">
<dt id="stringview.StringView.startswith">
<code class="descname">startswith</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.startswith" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if S starts with the specified prefix, False otherwise.
With optional <cite>start</cite>, test S beginning at that position.
With optional <cite>end</cite>, stop comparing S at that position.
prefix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="method">
<dt id="stringview.StringView.strip">
<code class="descname">strip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stringview.StringView.strip" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the StringView <cite>self</cite> with leading and trailing
whitespace removed.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-versionnumber">
<span id="module-versionnumber"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">versionnumber</span></code><a class="headerlink" href="#module-versionnumber" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="ReferenceManual.html" class="btn btn-neutral" title="DHParser Reference Manual" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Eckhart Arnold.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.8',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>