

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DHParser.syntaxtree &mdash; DHParser 0.8 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> DHParser
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../StepByStepGuide.html">DHParser’s Step by Step Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../UserGuide.html">DHParser User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ReferenceManual.html">DHParser Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ModuleReference.html">Module Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">DHParser</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>DHParser.syntaxtree</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for DHParser.syntaxtree</h1><div class="highlight"><pre>
<span></span><span class="c1"># syntaxtree.py - syntax tree classes for DHParser</span>
<span class="c1">#</span>
<span class="c1"># Copyright 2016  by Eckhart Arnold (arnold@badw.de)</span>
<span class="c1">#                 Bavarian Academy of Sciences an Humanities (badw.de)</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or</span>
<span class="c1"># implied.  See the License for the specific language governing</span>
<span class="c1"># permissions and limitations under the License.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module ``syntaxtree`` defines the ``Node``-class for syntax trees as well</span>
<span class="sd">as an abstract base class for parser-objects. The latter is defined</span>
<span class="sd">here, because node-objects refer to parser-objects. All concrete</span>
<span class="sd">parser classes are defined in the ``parse`` module.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">DHParser.error</span> <span class="k">import</span> <span class="n">Error</span><span class="p">,</span> <span class="n">linebreaks</span><span class="p">,</span> <span class="n">line_col</span>
<span class="kn">from</span> <span class="nn">DHParser.stringview</span> <span class="k">import</span> <span class="n">StringView</span>
<span class="kn">from</span> <span class="nn">DHParser.toolkit</span> <span class="k">import</span> <span class="n">re</span><span class="p">,</span> <span class="n">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">AbstractSet</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ParserBase&#39;</span><span class="p">,</span>
           <span class="s1">&#39;WHITESPACE_PTYPE&#39;</span><span class="p">,</span>
           <span class="s1">&#39;PLAINTEXT_PTYPE&#39;</span><span class="p">,</span>
           <span class="s1">&#39;TOKEN_PTYPE&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MockParser&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ZombieParser&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ZOMBIE_PARSER&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ZOMBIE_NODE&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Node&#39;</span><span class="p">,</span>
           <span class="s1">&#39;RootNode&#39;</span><span class="p">,</span>
           <span class="s1">&#39;parse_sxpr&#39;</span><span class="p">,</span>
           <span class="s1">&#39;parse_xml&#39;</span><span class="p">,</span>
           <span class="s1">&#39;flatten_sxpr&#39;</span><span class="p">,</span>
           <span class="s1">&#39;flatten_xml&#39;</span><span class="p">)</span>


<span class="c1">#######################################################################</span>
<span class="c1">#</span>
<span class="c1"># parser base and mock parsers</span>
<span class="c1">#</span>
<span class="c1">#######################################################################</span>


<span class="k">class</span> <span class="nc">ParserBase</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ParserBase is the base class for all real and mock parser classes.</span>
<span class="sd">    It is defined here, because Node objects require a parser object</span>
<span class="sd">    for instantiation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>  <span class="c1"># , pbases=frozenset()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># type: str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptype</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>  <span class="c1"># type: str</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptype</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39; = &#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the name of the parser or the empty string &#39;&#39; for unnamed</span>
<span class="sd">        parsers.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ptype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the type of the parser. By default this is the parser&#39;s</span>
<span class="sd">        class name preceded by a colon, e.g. &#39;:ZeroOrMore&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the parser&#39;s name if it has a name and repr()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets any parser variables. (Should be overridden.)&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Grammar object to which the parser belongs. If not</span>
<span class="sd">        yet connected to any Grammar object, None is returned.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Applies the function `func` to the parser. Returns False, if</span>
<span class="sd">        - for whatever reason - the functions has not been applied, True</span>
<span class="sd">        otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="n">WHITESPACE_PTYPE</span> <span class="o">=</span> <span class="s1">&#39;:Whitespace&#39;</span>
<span class="n">PLAINTEXT_PTYPE</span> <span class="o">=</span> <span class="s1">&#39;:PlainText&#39;</span>
<span class="n">TOKEN_PTYPE</span> <span class="o">=</span> <span class="s1">&#39;:Token&#39;</span>


<span class="k">class</span> <span class="nc">MockParser</span><span class="p">(</span><span class="n">ParserBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MockParser objects can be used to reconstruct syntax trees from a</span>
<span class="sd">    serialized form like S-expressions or XML. Mock objects can mimic</span>
<span class="sd">    different parser types by assigning them a ptype on initialization.</span>

<span class="sd">    Mock objects should not be used for anything other than</span>
<span class="sd">    syntax tree (re-)construction. In all other cases where a parser</span>
<span class="sd">    object substitute is needed, chose the singleton ZOMBIE_PARSER.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ptype</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>  <span class="c1"># , pbases=frozenset()):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">ptype</span> <span class="ow">or</span> <span class="n">ptype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;:&#39;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptype</span> <span class="o">=</span> <span class="n">ptype</span> <span class="ow">or</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>


<span class="k">class</span> <span class="nc">ZombieParser</span><span class="p">(</span><span class="n">MockParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Serves as a substitute for a Parser instance.</span>

<span class="sd">    ``ZombieParser`` is the class of the singelton object</span>
<span class="sd">    ``ZOMBIE_PARSER``. The  ``ZOMBIE_PARSER`` has a name and can be</span>
<span class="sd">    called, but it never matches. It serves as a substitute where only</span>
<span class="sd">    these (or one of these properties) is needed, but no real Parser-</span>
<span class="sd">    object is instantiated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alive</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ZombieParser</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;__ZOMBIE__&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">alive</span><span class="p">,</span> <span class="s2">&quot;There can be only one!&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">ZombieParser</span><span class="p">,</span> <span class="s2">&quot;No derivatives, please!&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">alive</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Better call Saul ;-)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>


<span class="n">ZOMBIE_PARSER</span> <span class="o">=</span> <span class="n">ZombieParser</span><span class="p">()</span>


<span class="c1">#######################################################################</span>
<span class="c1">#</span>
<span class="c1"># syntaxtree nodes</span>
<span class="c1">#</span>
<span class="c1">#######################################################################</span>


<span class="n">ChildrenType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="n">NoChildren</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ChildrenType</span><span class="p">,</span> <span class="p">())</span>  <span class="c1"># type: ChildrenType</span>
<span class="n">StrictResultType</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">ChildrenType</span><span class="p">,</span> <span class="n">StringView</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">ResultType</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">ChildrenType</span><span class="p">,</span> <span class="s1">&#39;Node&#39;</span><span class="p">,</span> <span class="n">StringView</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">flatten_sxpr</span><span class="p">(</span><span class="n">sxpr</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns S-expression ``sxpr`` as a one-liner without unnecessary</span>
<span class="sd">    whitespace.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; flatten_sxpr(&#39;(a\\n    (b\\n        c\\n    )\\n)\\n&#39;)</span>
<span class="sd">    &#39;(a (b c))&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s(?=\))&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">sxpr</span><span class="p">))</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">flatten_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns an XML-tree as a one linter without unnecessary whitespace,</span>
<span class="sd">    i.e. only whitespace within leaf-nodes is preserved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+(?=&lt;\w)&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?&lt;=&lt;/\w+&gt;)\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">xml</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sized</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a node in the concrete or abstract syntax tree.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        tag_name (str):  The name of the node, which is either its</span>
<span class="sd">            parser&#39;s name or, if that is empty, the parser&#39;s class name</span>

<span class="sd">        result (str or tuple):  The result of the parser which</span>
<span class="sd">            generated this node, which can be either a string or a</span>
<span class="sd">            tuple of child nodes.</span>

<span class="sd">        children (tuple):  The tuple of child nodes or an empty tuple</span>
<span class="sd">            if there are no child nodes. READ ONLY!</span>

<span class="sd">        content (str):  Yields the contents of the tree as string. The</span>
<span class="sd">            difference to ``str(node)`` is that ``node.content`` does</span>
<span class="sd">            not add the error messages to the returned string.</span>

<span class="sd">        parser (Parser):  The parser which generated this node.</span>
<span class="sd">            WARNING: In case you use mock syntax trees for testing or</span>
<span class="sd">            parser replacement during the AST-transformation: DO NOT</span>
<span class="sd">            rely on this being a real parser object in any phase after</span>
<span class="sd">            parsing (i.e. AST-transformation and compiling), for</span>
<span class="sd">            example by calling ``isinstance(node.parer, ...)``.</span>

<span class="sd">        len (int):  The full length of the node&#39;s string result if the</span>
<span class="sd">            node is a leaf node or, otherwise, the concatenated string</span>
<span class="sd">            result&#39;s of its descendants. The figure always represents</span>
<span class="sd">            the length before AST-transformation and will never change</span>
<span class="sd">            through AST-transformation. READ ONLY!</span>

<span class="sd">        pos (int):  the position of the node within the parsed text.</span>

<span class="sd">            The value of ``pos`` is -1 meaning invalid by default.</span>
<span class="sd">            Setting this value will set the positions of all child</span>
<span class="sd">            nodes relative to this value.</span>

<span class="sd">            To set the pos values of all nodes in a syntax tree, the</span>
<span class="sd">            pos value of the root node should be set to 0 right</span>
<span class="sd">            after parsing.</span>

<span class="sd">            Other than that, this value should be considered READ ONLY.</span>
<span class="sd">            At any rate, it should only be reassigned during the parsing</span>
<span class="sd">            stage and never during or after the AST-transformation.</span>

<span class="sd">        errors (list):  A list of all errors that occured on this node.</span>

<span class="sd">        attributes (dict): An optional dictionary of XML-attributes. This</span>
<span class="sd">            dictionary is created lazily upon first usage. The attributes</span>
<span class="sd">            will only be shown in the XML-Representation, not in the</span>
<span class="sd">            S-Expression-output.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_result&#39;</span><span class="p">,</span> <span class="s1">&#39;children&#39;</span><span class="p">,</span> <span class="s1">&#39;_len&#39;</span><span class="p">,</span> <span class="s1">&#39;_pos&#39;</span><span class="p">,</span> <span class="s1">&#39;parser&#39;</span><span class="p">,</span> <span class="s1">&#39;errors&#39;</span><span class="p">,</span> <span class="s1">&#39;_xml_attr&#39;</span><span class="p">,</span> <span class="s1">&#39;_content&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">ResultType</span><span class="p">,</span> <span class="n">leafhint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the ``Node``-object with the ``Parser``-Instance</span>
<span class="sd">        that generated the node and the parser&#39;s result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>               <span class="c1"># type: List[Error]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>                  <span class="c1"># type: int</span>
        <span class="c1"># Assignment to self.result initializes the attributes _result, children and _len</span>
        <span class="c1"># The following if-clause is merely an optimization, i.e. a fast-path for leaf-Nodes</span>
        <span class="k">if</span> <span class="n">leafhint</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="n">result</span>       <span class="c1"># type: StrictResultType</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_content</span> <span class="o">=</span> <span class="kc">None</span>        <span class="c1"># type: Optional[str]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">NoChildren</span>  <span class="c1"># type: ChildrenType</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>              <span class="c1"># type: int  # lazy evaluation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">parser</span> <span class="ow">or</span> <span class="n">ZOMBIE_PARSER</span>


    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">content</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39; &lt;&lt;&lt; Error on &quot;</span><span class="si">%s</span><span class="s1">&quot; | </span><span class="si">%s</span><span class="s1"> &gt;&gt;&gt; &#39;</span> <span class="o">%</span> \
                   <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">message</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">s</span>


    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mpargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;ptype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">ptype</span><span class="p">}</span>
        <span class="n">parg</span> <span class="o">=</span> <span class="s2">&quot;MockParser(</span><span class="si">{name}</span><span class="s2">, </span><span class="si">{ptype}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">mpargs</span><span class="p">)</span>
        <span class="n">rarg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="k">else</span> \
               <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Node(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parg</span><span class="p">,</span> <span class="n">rarg</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> \
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>


    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># A node that is not None is always True, even if it&#39;s empty</span>
        <span class="k">return</span> <span class="kc">True</span>


    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equality of nodes: Two nodes are considered as equal, if their tag</span>
<span class="sd">        name is the same and if their results are equal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tag_name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">result</span>


    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tag_name</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="o">=</span><span class="p">{}):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>
        <span class="k">return</span> <span class="n">other</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_or_tagname</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the child node with the given index if ``index_or_tagname`` is</span>
<span class="sd">        an integer or the first child node with the given tag name. Examples::</span>

<span class="sd">            &gt;&gt;&gt; tree = parse_sxpr(&#39;(a (b &quot;X&quot;) (X (c &quot;d&quot;)) (e (X &quot;F&quot;)))&#39;)</span>
<span class="sd">            &gt;&gt;&gt; flatten_sxpr(tree[0].as_sxpr())</span>
<span class="sd">            &#39;(b &quot;X&quot;)&#39;</span>
<span class="sd">            &gt;&gt;&gt; flatten_sxpr(tree[&quot;X&quot;].as_sxpr())</span>
<span class="sd">            &#39;(X (c &quot;d&quot;))&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            index_or_tagname(str): Either an index of a child node or a</span>
<span class="sd">                tag name.</span>
<span class="sd">        Returns:</span>
<span class="sd">            Node: All nodes which have a given tag name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index_or_tagname</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">index_or_tagname</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag_name</span> <span class="o">==</span> <span class="n">index_or_tagname</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">child</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">index_or_tagname</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Leave nodes have no children that can be indexed!&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if a child with the given tag name exists.</span>
<span class="sd">        Args:</span>
<span class="sd">            tag_name (str): tag_name which will be searched among to immediate</span>
<span class="sd">                descendants of this node.</span>
<span class="sd">        Returns:</span>
<span class="sd">            bool:  True, if at least one descendant node with the given tag</span>
<span class="sd">                name exists, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assert isinstance(tag_name, str)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag_name</span> <span class="o">==</span> <span class="n">tag_name</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Leave node cannot contain other nodes&#39;</span><span class="p">)</span>
        <span class="c1"># generator = self.select_by_tag(tag_name, False)</span>
        <span class="c1"># try:</span>
        <span class="c1">#     generator.__next__()</span>
        <span class="c1">#     return True</span>
        <span class="c1"># except StopIteration:</span>
        <span class="c1">#     return False</span>


    <span class="nd">@property</span>   <span class="c1"># this needs to be a (dynamic) property, in case sef.parser gets updated</span>
    <span class="k">def</span> <span class="nf">tag_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tage name of Node, i.e. the name for XML or</span>
<span class="sd">        S-expression representation. By default the tag name is the</span>
<span class="sd">        name of the node&#39;s parser or, if the node&#39;s parser is unnamed, the</span>
<span class="sd">        node&#39;s parser&#39;s `ptype`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">ptype</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrictResultType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the result from the parser that created the node.</span>
<span class="sd">        Error messages are not included in the result. Use `self.content()`</span>
<span class="sd">        if the result plus any error messages is needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result</span>


    <span class="nd">@result</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">ResultType</span><span class="p">):</span>
        <span class="c1"># # made obsolete by static type checking with mypy</span>
        <span class="c1"># assert ((isinstance(result, tuple) and all(isinstance(child, Node) for child in result))</span>
        <span class="c1">#         or isinstance(result, Node)</span>
        <span class="c1">#         or isinstance(result, str)), str(result)</span>
        <span class="c1"># Possible optimization: Do not allow single nodes as argument:</span>
        <span class="c1"># assert not isinstance(result, Node)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>        <span class="c1"># lazy evaluation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_content</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">result</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="n">result</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">NoChildren</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="n">result</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">content</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns content as string, omitting error messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_content</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_content</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">content</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># self._content = self._result</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_content</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_result</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_content</span>  <span class="c1"># self._result might be more efficient as a string!?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_content</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return structure (and content) as S-expression on a single line</span>
<span class="sd">        without any line breaks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">flatten_sxpr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_sxpr</span><span class="p">(</span><span class="n">showerrors</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the position of the Node&#39;s content in the source text.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Position value not initialized!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>


    <span class="k">def</span> <span class="nf">init_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Node&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (Re-)initialize position value. Usually, the parser guard</span>
<span class="sd">        (`parsers.add_parser_guard()`) takes care of assigning the</span>
<span class="sd">        position in the document to newly created nodes. However,</span>
<span class="sd">        where Nodes are created outside the reach of the parser</span>
<span class="sd">        guard, their document-position must be assigned manually.</span>
<span class="sd">        This function recursively reassigns the position values</span>
<span class="sd">        of the child nodes, too.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="n">pos</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="s2">&quot;pos mismatch </span><span class="si">%i</span><span class="s2"> != </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="c1"># recursively adjust pos-values of all children</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">init_pos</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary of XML-Attributes attached to the Node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_xml_attr&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xml_attr</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xml_attr</span>


    <span class="k">def</span> <span class="nf">_tree_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tab</span><span class="p">,</span> <span class="n">open_fn</span><span class="p">,</span> <span class="n">close_fn</span><span class="p">,</span> <span class="n">data_fn</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a tree representation of this node and its children</span>
<span class="sd">        in string from.</span>

<span class="sd">        The kind ot tree-representation that is determined by several</span>
<span class="sd">        function parameters. This could be an XML-representation or a</span>
<span class="sd">        lisp-like S-expression.</span>

<span class="sd">        Args:</span>
<span class="sd">            tab (str):  The indentation string, e.g. &#39;\t&#39; or &#39;    &#39;</span>
<span class="sd">            open_fn:   (Node-&gt;str) A function that returns an opening</span>
<span class="sd">                string (e.g. an XML-tag_name) for a given node</span>
<span class="sd">            close_fn:  (Node-&gt;str) A function that returns a closeF</span>
<span class="sd">                string (e.g. an XML-tag_name) for a given node.</span>
<span class="sd">            data_fn:   (str-&gt;str) A function that filters the data string</span>
<span class="sd">                before printing, e.g. to add quotation marks</span>

<span class="sd">        Returns (str):</span>
<span class="sd">            A string that contains a (serialized) tree representation</span>
<span class="sd">            of the node and its children.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">open_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">close_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">+</span> <span class="n">tail</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>

        <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">density</span> <span class="o">&amp;</span> <span class="mi">2</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">subtree</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">_tree_repr</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">open_fn</span><span class="p">,</span> <span class="n">close_fn</span><span class="p">,</span> <span class="n">data_fn</span><span class="p">,</span> <span class="n">density</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">content</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">tab</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subtree</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">head</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">+</span> <span class="n">tail</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># safe, because if there are no children, result is a string</span>
        <span class="k">if</span> <span class="n">density</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">res</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># and head[0] == &quot;&lt;&quot;:</span>
            <span class="c1"># except for XML, add a gap between opening statement and content</span>
            <span class="n">gap</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="k">if</span> <span class="n">head</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&gt;&#39;</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
            <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">+</span> <span class="n">gap</span> <span class="o">+</span> <span class="n">data_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span> <span class="o">+</span> <span class="n">tail</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">head</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">tab</span> <span class="o">+</span> <span class="n">data_fn</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)])</span> <span class="o">+</span> <span class="n">tail</span>


    <span class="k">def</span> <span class="nf">as_sxpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">compact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">showerrors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">indentation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns content as S-expression, i.e. in lisp-like form.</span>

<span class="sd">        Args:</span>
<span class="sd">            src:  The source text or `None`. In case the source text is</span>
<span class="sd">                given the position of the element in the text will be</span>
<span class="sd">                reported as line and column.</span>
<span class="sd">            compact:  If True a compact representation is returned where</span>
<span class="sd">                brackets are omitted and only the indentation indicates the</span>
<span class="sd">                tree structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">left_bracket</span><span class="p">,</span> <span class="n">right_bracket</span><span class="p">,</span> <span class="n">density</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">compact</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">lbreaks</span> <span class="o">=</span> <span class="n">linebreaks</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="k">if</span> <span class="n">src</span> <span class="k">else</span> <span class="p">[]</span>  <span class="c1"># type: List[int]</span>

        <span class="k">def</span> <span class="nf">opening</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Returns the opening string for the representation of `node`.&quot;&quot;&quot;</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_bracket</span><span class="p">,</span>  <span class="n">node</span><span class="o">.</span><span class="n">tag_name</span><span class="p">]</span>
            <span class="c1"># s += &quot; &#39;(pos %i)&quot; % node.add_pos</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;_xml_attr&#39;</span><span class="p">):</span>
                <span class="n">txt</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="s1">&#39; `(</span><span class="si">%s</span><span class="s1"> &quot;</span><span class="si">%s</span><span class="s1">&quot;)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">txt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; `(pos </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">line_col</span><span class="p">(</span><span class="n">lbreaks</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">)))</span>
            <span class="c1"># if node.error_flag:   # just for debugging error collecting</span>
            <span class="c1">#     txt += &quot; HAS ERRORS&quot;</span>
            <span class="k">if</span> <span class="n">showerrors</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                <span class="n">txt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; `(err `</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">errors</span><span class="p">))</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">def</span> <span class="nf">closing</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Returns the closing string for the representation of `node`.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">right_bracket</span>

        <span class="k">def</span> <span class="nf">pretty</span><span class="p">(</span><span class="n">strg</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Encloses `strg` with the right kind of quotation marks.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">strg</span> <span class="k">if</span> <span class="n">strg</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> \
                <span class="k">else</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">strg</span> <span class="k">if</span> <span class="n">strg</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> \
                <span class="k">else</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">strg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\&quot;&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_repr</span><span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">indentation</span><span class="p">,</span> <span class="n">opening</span><span class="p">,</span> <span class="n">closing</span><span class="p">,</span> <span class="n">pretty</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">as_xml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">showerrors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">indentation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns content as XML-tree.</span>

<span class="sd">        Args:</span>
<span class="sd">            src:  The source text or `None`. In case the source text is</span>
<span class="sd">                given the position will also be reported as line and</span>
<span class="sd">                column.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">opening</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Returns the opening string for the representation of `node`.&quot;&quot;&quot;</span>            
            <span class="n">txt</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">tag_name</span><span class="p">]</span>
            <span class="n">has_reserved_attrs</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;_xml_attr&#39;</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="nb">any</span> <span class="p">(</span><span class="n">r</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attributes</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;err&#39;</span><span class="p">,</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;col&#39;</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;_xml_attr&#39;</span><span class="p">):</span>
                <span class="n">txt</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="s1">&#39; </span><span class="si">%s</span><span class="s1">=&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">src</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_reserved_attrs</span><span class="p">:</span>
                <span class="n">txt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; line=&quot;</span><span class="si">%i</span><span class="s1">&quot; col=&quot;</span><span class="si">%i</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">line_col</span><span class="p">(</span><span class="n">line_breaks</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">showerrors</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">errors</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_reserved_attrs</span><span class="p">:</span>
                <span class="n">txt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; err=&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\&quot;&#39;</span><span class="p">)</span>
                                                 <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">errors</span><span class="p">))</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">txt</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">closing</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns the closing string for the representation of `node`.&quot;&quot;&quot;</span>            
            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&lt;/&#39;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">tag_name</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>

        <span class="n">line_breaks</span> <span class="o">=</span> <span class="n">linebreaks</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="k">if</span> <span class="n">src</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_repr</span><span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">indentation</span><span class="p">,</span> <span class="n">opening</span><span class="p">,</span> <span class="n">closing</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">include_root</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds nodes in the tree that fulfill a given criterion.</span>

<span class="sd">        `select` is a generator that yields all nodes for which the</span>
<span class="sd">        given `match_function` evaluates to True. The tree is</span>
<span class="sd">        traversed pre-order.</span>

<span class="sd">        See function `Node.select_by_tag` for some examples.</span>

<span class="sd">        Args:</span>
<span class="sd">            match_function (function): A function  that takes as Node</span>
<span class="sd">                object as argument and returns True or False</span>
<span class="sd">            include_root (bool): If False, only descendant nodes will be</span>
<span class="sd">                checked for a match.</span>
<span class="sd">        Yields:</span>
<span class="sd">            Node: All nodes of the tree for which</span>
<span class="sd">            ``match_function(node)`` returns True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">include_root</span> <span class="ow">and</span> <span class="n">match_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">match_function</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">node</span>


    <span class="k">def</span> <span class="nf">select_by_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">AbstractSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                      <span class="n">include_root</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator that runs through all descendants that have one</span>
<span class="sd">        of the given tag names.</span>

<span class="sd">        Examples::</span>

<span class="sd">            &gt;&gt;&gt; tree = parse_sxpr(&#39;(a (b &quot;X&quot;) (X (c &quot;d&quot;)) (e (X &quot;F&quot;)))&#39;)</span>
<span class="sd">            &gt;&gt;&gt; list(flatten_sxpr(item.as_sxpr()) for item in tree.select_by_tag(&quot;X&quot;, False))</span>
<span class="sd">            [&#39;(X (c &quot;d&quot;))&#39;, &#39;(X &quot;F&quot;)&#39;]</span>
<span class="sd">            &gt;&gt;&gt; list(flatten_sxpr(item.as_sxpr()) for item in tree.select_by_tag({&quot;X&quot;, &quot;b&quot;}, False))</span>
<span class="sd">            [&#39;(b &quot;X&quot;)&#39;, &#39;(X (c &quot;d&quot;))&#39;, &#39;(X &quot;F&quot;)&#39;]</span>
<span class="sd">            &gt;&gt;&gt; any(tree.select_by_tag(&#39;a&#39;, False))</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; list(flatten_sxpr(item.as_sxpr()) for item in tree.select_by_tag(&#39;a&#39;, True))</span>
<span class="sd">            [&#39;(a (b &quot;X&quot;) (X (c &quot;d&quot;)) (e (X &quot;F&quot;)))&#39;]</span>
<span class="sd">            &gt;&gt;&gt; flatten_sxpr(next(tree.select_by_tag(&quot;X&quot;, False)).as_sxpr())</span>
<span class="sd">            &#39;(X (c &quot;d&quot;))&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            tag_name(set): A tag name or set of tag names that is being</span>
<span class="sd">                searched for</span>
<span class="sd">            include_root (bool): If False, only descendant nodes will be</span>
<span class="sd">                checked for a match.</span>
<span class="sd">        Yields:</span>
<span class="sd">            Node: All nodes which have a given tag name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">tag_names</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">tag_names</span><span class="p">})</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">tag_name</span> <span class="ow">in</span> <span class="n">tag_names</span><span class="p">,</span> <span class="n">include_root</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">pick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Picks the first descendant with one of the given tag_names.</span>

<span class="sd">        This function is just syntactic sugar for</span>
<span class="sd">        ``next(node.select_by_tag(tag_names, False))``. However, rather than</span>
<span class="sd">        raising a StopIterationError if no descendant with the given tag-name</span>
<span class="sd">        exists, it returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select_by_tag</span><span class="p">(</span><span class="n">tag_names</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">tree_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively counts the number of nodes in the tree including the root node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tree_size</span><span class="p">()</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">RootNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;TODO: Add Documentation!!!</span>

<span class="sd">        errors (list):  A list of all errors that have occured so far during</span>
<span class="sd">                processing (i.e. parsing, AST-transformation, compiling)</span>
<span class="sd">                of this tree.</span>

<span class="sd">        error_flag (int):  the highest warning or error level of all errors</span>
<span class="sd">                that occurred.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;RootNode&#39;</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ZOMBIE_PARSER</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err_nodes_keep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_flag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swallow</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="c1"># def _propagate_errors(self):</span>
    <span class="c1">#     if not self.all_errors or not self.error_propagation:</span>
    <span class="c1">#         return</span>
    <span class="c1">#     self.all_errors.sort(key=lambda e: e.pos)</span>
    <span class="c1">#     i = 0</span>
    <span class="c1">#     for leaf in self.select(lambda nd: not nd.children, False):</span>
    <span class="c1">#         leaf.errors = []</span>
    <span class="c1">#         while i &lt; len(self.all_errors) \</span>
    <span class="c1">#                 and leaf.pos &lt;= self.all_errors[i].add_pos &lt; leaf.add_pos + leaf.len:</span>
    <span class="c1">#             leaf._errors.append(self.all_errors[i])</span>
    <span class="c1">#             i += 1</span>
    <span class="c1">#         if i &gt;= len(self.all_errors):</span>
    <span class="c1">#             break</span>
    <span class="c1">#</span>
    <span class="c1"># def _propagate_new_error(self, error):</span>
    <span class="c1">#     if self.error_propagation:</span>
    <span class="c1">#         for leaf in self.select(lambda nd: not nd.children, True):</span>
    <span class="c1">#             if leaf.pos &lt;= error.add_pos &lt; leaf.add_pos + leaf.len:</span>
    <span class="c1">#                 leaf._errors.append(error)</span>
    <span class="c1">#                 break</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             assert False, &quot;Error %s at pos %i out of bounds&quot; % (str(error), error.add_pos)</span>

    <span class="k">def</span> <span class="nf">swallow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;RootNode&#39;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parser</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;_xml_attr&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xml_attr</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_xml_attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_content</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_content</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="n">Error</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;RootNode&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds an Error object to the tree, locating it at a specific node.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_flag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error_flag</span><span class="p">,</span> <span class="n">error</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err_nodes_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">new_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
                  <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                  <span class="n">code</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">Error</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;RootNode&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an error to this tree, locating it at a specific node.</span>
<span class="sd">        Parameters:</span>
<span class="sd">            pos(int):     The position of the error in the source text</span>
<span class="sd">            message(str): A string with the error message.abs</span>
<span class="sd">            code(int):    An error code to identify the kind of error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">Error</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">collect_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Error</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns the list of errors, ordered bv their position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for node in self.err_nodes:  # lazy evaluation of positions</span>
        <span class="c1">#     for err in node.errors:  # moved to error.Error.pos</span>
        <span class="c1">#         err.pos = node.pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_errors</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_nodes_keep</span><span class="p">:</span>  <span class="c1"># redundant: consider removing Error.Error._node_keep</span>
            <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">error</span><span class="o">.</span><span class="n">_pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">error</span><span class="o">.</span><span class="n">_pos</span> <span class="o">&lt;=</span> <span class="n">node</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">error</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err_nodes_keep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_errors</span>
        <span class="c1"># for error in self.all_errors:</span>
        <span class="c1">#     _ = error.pos</span>
        <span class="k">return</span> <span class="n">errors</span>


<span class="n">ZOMBIE_NODE</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">ZOMBIE_PARSER</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_sxpr</span><span class="p">(</span><span class="n">sxpr</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a tree of nodes from an S-expression.</span>

<span class="sd">    This can - among other things - be used for deserialization of trees that</span>
<span class="sd">    have been serialized with `Node.as_sxpr()` or as a convenient way to</span>
<span class="sd">    generate test data.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; parse_sxpr(&quot;(a (b c))&quot;).as_sxpr()</span>
<span class="sd">    &#39;(a\\n    (b\\n        &quot;c&quot;\\n    )\\n)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sxpr</span> <span class="o">=</span> <span class="n">StringView</span><span class="p">(</span><span class="n">sxpr</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">mock_parsers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">next_block</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">StringView</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator that yields all characters until the next closing bracket</span>
<span class="sd">        that does not match an opening bracket matched earlier within the same</span>
<span class="sd">        package.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;(&quot; expected, not &#39;</span> <span class="o">+</span> <span class="n">s</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
                <span class="c1"># assert s[0] == &#39;(&#39;, s</span>
                <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
                        <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
                        <span class="n">level</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">yield</span> <span class="n">s</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Malformed S-expression. Unprocessed part: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span> \
                <span class="k">else</span> <span class="s1">&#39;Malformed S-expression. Closing bracket(s) &quot;)&quot; missing.&#39;</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inner_parser</span><span class="p">(</span><span class="n">sxpr</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sxpr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;(&quot; expected, not &#39;</span> <span class="o">+</span> <span class="n">sxpr</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
        <span class="c1"># assert sxpr[0] == &#39;(&#39;, sxpr</span>
        <span class="n">sxpr</span> <span class="o">=</span> <span class="n">sxpr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\w:]+&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Malformed S-expression Node-tagname or identifier expected, &#39;</span>
                                 <span class="s1">&#39;not &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">sxpr</span><span class="p">[:</span><span class="mi">40</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">begin</span>
        <span class="n">tagname</span> <span class="o">=</span> <span class="n">sxpr</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">class_name</span> <span class="o">=</span> <span class="p">(</span><span class="n">tagname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">])[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">sxpr</span> <span class="o">=</span> <span class="n">sxpr</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sxpr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">inner_parser</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">next_block</span><span class="p">(</span><span class="n">sxpr</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">sxpr</span> <span class="ow">and</span> <span class="n">sxpr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
                <span class="c1"># parse attributes</span>
                <span class="k">while</span> <span class="n">sxpr</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;`(&quot;</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
                    <span class="c1"># read very special attribute pos</span>
                    <span class="k">if</span> <span class="n">sxpr</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;pos&quot;</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                        <span class="n">pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sxpr</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="c1"># ignore very special attribute err</span>
                    <span class="k">elif</span> <span class="n">sxpr</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;err&quot;</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;`&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
                        <span class="k">while</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
                    <span class="c1"># read attributes</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">attr</span> <span class="o">=</span> <span class="n">sxpr</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">sxpr</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">attributes</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="n">sxpr</span> <span class="o">=</span> <span class="n">sxpr</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="c1"># parse content</span>
                <span class="k">for</span> <span class="n">qtmark</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&quot;&quot;&quot;&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;&#39;&#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">]:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">qtmark</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;.*?&#39;</span> <span class="o">+</span> <span class="n">qtmark</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">begin</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qtmark</span><span class="p">)</span>
                        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sxpr</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">end</span> <span class="o">-</span> <span class="n">i</span><span class="p">]))</span>
                        <span class="n">sxpr</span> <span class="o">=</span> <span class="n">sxpr</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?:(?!\)).)*&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">))</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="n">sxpr</span><span class="o">.</span><span class="n">begin</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sxpr</span><span class="p">[:</span><span class="n">end</span><span class="p">]))</span>
                    <span class="n">sxpr</span> <span class="o">=</span> <span class="n">sxpr</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">mock_parsers</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">tagname</span><span class="p">,</span> <span class="n">MockParser</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">class_name</span><span class="p">)),</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>

    <span class="k">return</span> <span class="n">inner_parser</span><span class="p">(</span><span class="n">sxpr</span><span class="p">)</span>


<span class="n">RX_WHITESPACE_TAIL</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*$&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a tree of nodes from a (Pseudo-)XML-source.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xml</span> <span class="o">=</span> <span class="n">StringView</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
    <span class="n">PlainText</span> <span class="o">=</span> <span class="n">MockParser</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">PLAINTEXT_PTYPE</span><span class="p">)</span>
    <span class="n">mock_parsers</span> <span class="o">=</span> <span class="p">{</span><span class="n">PLAINTEXT_PTYPE</span><span class="p">:</span> <span class="n">PlainText</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">parse_attributes</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">StringView</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parses a sqeuence of XML-Attributes. Returns the string-slice</span>
<span class="sd">        beginning after the end of the attributes.&quot;&quot;&quot;</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">restart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*(?P&lt;attr&gt;\w+)\s*=\s*&quot;(?P&lt;value&gt;.*)&quot;\s*&#39;</span><span class="p">)):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
            <span class="n">attributes</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;attr&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="n">restart</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">begin</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">restart</span><span class="p">:],</span> <span class="n">attributes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_opening_tag</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">StringView</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parses an opening tag. Returns the string segment following the</span>
<span class="sd">        the opening tag, the tag name, a dictionary of attributes and</span>
<span class="sd">        a flag indicating whether the tag is actually a solitary tag as</span>
<span class="sd">        indicated by a slash at the end, i.e. &lt;br/&gt;.&quot;&quot;&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;\s*(?P&lt;tagname&gt;[\w:]+)\s*&#39;</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">match</span>
        <span class="n">tagname</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;tagname&#39;</span><span class="p">]</span>
        <span class="n">section</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">begin</span><span class="p">:]</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">parse_attributes</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tagname</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span>

    <span class="k">def</span> <span class="nf">parse_closing_tag</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">StringView</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parses a closing tag and returns the string segment, just after</span>
<span class="sd">        the closing tag.&quot;&quot;&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;/\s*(?P&lt;tagname&gt;[\w:]+)&gt;&#39;</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">match</span>
        <span class="n">tagname</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;tagname&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">begin</span><span class="p">:],</span> <span class="n">tagname</span>

    <span class="k">def</span> <span class="nf">parse_leaf_content</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">StringView</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parses a piece of the content of a tag, just until the next opening,</span>
<span class="sd">        closing or solitary tag is reached.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&lt;&quot;</span> <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">s</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">parse_full_content</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">StringView</span><span class="p">,</span> <span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parses the full content of a tag, starting right at the beginning</span>
<span class="sd">        of the opening tag and ending right after the closing tag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">tagname</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">solitary</span> <span class="o">=</span> <span class="n">parse_opening_tag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">class_name</span> <span class="o">=</span> <span class="p">(</span><span class="n">tagname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">])[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">solitary</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">s</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">s</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&lt;/&quot;</span><span class="p">:</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">leaf</span> <span class="o">=</span> <span class="n">parse_leaf_content</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">leaf</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">RX_WHITESPACE_TAIL</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">PlainText</span><span class="p">,</span> <span class="n">leaf</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&lt;/&quot;</span><span class="p">:</span>
                    <span class="n">s</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">parse_full_content</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">closing_tagname</span> <span class="o">=</span> <span class="n">parse_closing_tag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">tagname</span> <span class="o">==</span> <span class="n">closing_tagname</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">ptype</span> <span class="o">==</span> <span class="n">PLAINTEXT_PTYPE</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="n">mock_parsers</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">tagname</span><span class="p">,</span> <span class="n">MockParser</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">class_name</span><span class="p">)),</span> <span class="n">result</span><span class="p">)</span>

    <span class="n">match_header</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;(?!\?)&#39;</span><span class="p">))</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">match_header</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">if</span> <span class="n">match_header</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">parse_full_content</span><span class="p">(</span><span class="n">xml</span><span class="p">[</span><span class="n">start</span><span class="p">:])</span>
    <span class="k">assert</span> <span class="n">_</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">RX_WHITESPACE_TAIL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree</span>

<span class="c1"># if __name__ == &quot;__main__&quot;:</span>
<span class="c1">#     st = parse_sxpr(&quot;(alpha (beta (gamma i\nj\nk) (delta y)) (epsilon z))&quot;)</span>
<span class="c1">#     print(st.as_sxpr())</span>
<span class="c1">#     print(st.as_xml())</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Eckhart Arnold.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.8',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>