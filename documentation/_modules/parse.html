

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>parse &mdash; DHParser 0.8 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="DHParser 0.8 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> DHParser
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../StepByStepGuide.html">DHParser’s Step by Step Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UserGuide.html">DHParser User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual.html">DHParser Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ModuleReference.html">Module Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DHParser</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>parse</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for parse</h1><div class="highlight"><pre>
<span></span><span class="c1"># parse.py - parser combinators for DHParser</span>
<span class="c1">#</span>
<span class="c1"># Copyright 2016  by Eckhart Arnold (arnold@badw.de)</span>
<span class="c1">#                 Bavarian Academy of Sciences an Humanities (badw.de)</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or</span>
<span class="c1"># implied.  See the License for the specific language governing</span>
<span class="c1"># permissions and limitations under the License.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module ``parse`` contains the python classes and functions for</span>
<span class="sd">DHParser&#39;s packrat-parser. It&#39;s central class is the</span>
<span class="sd">``Grammar``-class, which is the base class for any concrete</span>
<span class="sd">Grammar. Grammar-objects are callable and parsing is done by</span>
<span class="sd">calling a Grammar-object with a source text as argument.</span>

<span class="sd">The different parsing functions are callable descendants of class</span>
<span class="sd">``Parser``. Usually, they are organized in a tree and defined</span>
<span class="sd">within the namespace of a grammar-class. See ``ebnf.EBNFGrammar``</span>
<span class="sd">for an example.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">DHParser.error</span> <span class="k">import</span> <span class="n">Error</span><span class="p">,</span> <span class="n">linebreaks</span>
<span class="kn">from</span> <span class="nn">DHParser.log</span> <span class="k">import</span> <span class="n">is_logging</span><span class="p">,</span> <span class="n">HistoryRecord</span>
<span class="kn">from</span> <span class="nn">DHParser.preprocess</span> <span class="k">import</span> <span class="n">BEGIN_TOKEN</span><span class="p">,</span> <span class="n">END_TOKEN</span><span class="p">,</span> <span class="n">RX_TOKEN_NAME</span>
<span class="kn">from</span> <span class="nn">DHParser.stringview</span> <span class="k">import</span> <span class="n">StringView</span><span class="p">,</span> <span class="n">EMPTY_STRING_VIEW</span>
<span class="kn">from</span> <span class="nn">DHParser.syntaxtree</span> <span class="k">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">ParserBase</span><span class="p">,</span> <span class="n">WHITESPACE_PTYPE</span><span class="p">,</span> \
    <span class="n">TOKEN_PTYPE</span><span class="p">,</span> <span class="n">ZOMBIE_PARSER</span>
<span class="kn">from</span> <span class="nn">DHParser.toolkit</span> <span class="k">import</span> <span class="n">sane_parser_name</span><span class="p">,</span> <span class="n">escape_control_characters</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">DefaultDict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Parser&#39;</span><span class="p">,</span>
           <span class="s1">&#39;UnknownParserError&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Grammar&#39;</span><span class="p">,</span>
           <span class="s1">&#39;PreprocessorToken&#39;</span><span class="p">,</span>
           <span class="s1">&#39;RegExp&#39;</span><span class="p">,</span>
           <span class="s1">&#39;RE&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Token&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mixin_comment&#39;</span><span class="p">,</span>
           <span class="c1"># &#39;UnaryOperator&#39;,</span>
           <span class="c1"># &#39;NaryOperator&#39;,</span>
           <span class="s1">&#39;Synonym&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Option&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ZeroOrMore&#39;</span><span class="p">,</span>
           <span class="s1">&#39;OneOrMore&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Series&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Alternative&#39;</span><span class="p">,</span>
           <span class="s1">&#39;AllOf&#39;</span><span class="p">,</span>
           <span class="s1">&#39;SomeOf&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Unordered&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Lookahead&#39;</span><span class="p">,</span>
           <span class="s1">&#39;NegativeLookahead&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Lookbehind&#39;</span><span class="p">,</span>
           <span class="s1">&#39;NegativeLookbehind&#39;</span><span class="p">,</span>
           <span class="s1">&#39;last_value&#39;</span><span class="p">,</span>
           <span class="s1">&#39;counterpart&#39;</span><span class="p">,</span>
           <span class="s1">&#39;accumulate&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Capture&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Retrieve&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Pop&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Forward&#39;</span><span class="p">)</span>


<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># Grammar and parsing infrastructure</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>


<span class="n">LEFT_RECURSION_DEPTH</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># type: int</span>
<span class="c1"># because of python&#39;s recursion depth limit, this value ought not to be</span>
<span class="c1"># set too high. PyPy allows higher values than CPython</span>
<span class="n">MAX_DROPOUTS</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># type: int</span>
<span class="c1"># stop trying to recover parsing after so many errors</span>


<span class="k">def</span> <span class="nf">add_parser_guard</span><span class="p">(</span><span class="n">parser_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a wrapper function to a parser functions (i.e. Parser.__call__ method)</span>
<span class="sd">    that takes care of memoizing, left recursion and, optionally, tracing</span>
<span class="sd">    (aka &quot;history tracking&quot;) of parser calls. Returns the wrapped call.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">guarded_call</span><span class="p">(</span><span class="n">parser</span><span class="p">:</span> <span class="s1">&#39;Parser&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">grammar</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">grammar</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">document_length__</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">last_rb__loc__</span> <span class="o">&gt;=</span> <span class="n">location</span><span class="p">:</span>
                <span class="n">grammar</span><span class="o">.</span><span class="n">rollback_to__</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>

            <span class="c1"># if location has already been visited by the current parser,</span>
            <span class="c1"># return saved result</span>
            <span class="k">if</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">visited</span><span class="p">:</span>
                <span class="c1"># no history recording in case of meomized results</span>
                <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">location</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">history_tracking__</span><span class="p">:</span>
                <span class="n">grammar</span><span class="o">.</span><span class="n">call_stack__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
                <span class="n">grammar</span><span class="o">.</span><span class="n">moving_forward__</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># break left recursion at the maximum allowed depth</span>
            <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">left_recursion_handling__</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parser</span><span class="o">.</span><span class="n">recursion_counter</span><span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">LEFT_RECURSION_DEPTH</span><span class="p">:</span>
                    <span class="n">grammar</span><span class="o">.</span><span class="n">recursion_locations__</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>
                <span class="n">parser</span><span class="o">.</span><span class="n">recursion_counter</span><span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># run original __call__ method</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">parser_func</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">left_recursion_handling__</span><span class="p">:</span>
                <span class="n">parser</span><span class="o">.</span><span class="n">recursion_counter</span><span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="c1"># don&#39;t clear recursion_locations__ !!!</span>

            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># retrieve an earlier match result (from left recursion) if it exists</span>
                <span class="k">if</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">recursion_locations__</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">visited</span><span class="p">:</span>
                        <span class="n">node</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">location</span><span class="p">]</span>
                        <span class="c1"># TODO: maybe add a warning about occurrence of left-recursion here?</span>
                    <span class="c1"># don&#39;t overwrite any positive match (i.e. node not None) in the cache</span>
                    <span class="c1"># and don&#39;t add empty entries for parsers returning from left recursive calls!</span>
                <span class="k">elif</span> <span class="n">grammar</span><span class="o">.</span><span class="n">memoization__</span><span class="p">:</span>
                    <span class="c1"># otherwise also cache None-results</span>
                    <span class="n">parser</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">_pos</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">location</span>
                <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">_pos</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> &lt; </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">document_length__</span><span class="p">,</span> <span class="n">location</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">last_rb__loc__</span> <span class="o">&lt;</span> <span class="n">location</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">memoization__</span> <span class="ow">or</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">recursion_locations__</span><span class="p">)):</span>
                    <span class="c1"># - variable manipulating parsers will not be entered into the cache,</span>
                    <span class="c1">#   because caching would interfere with changes of variable state</span>
                    <span class="c1"># - in case of left recursion, the first recursive step that</span>
                    <span class="c1">#   matches will store its result in the cache</span>
                    <span class="n">parser</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>

            <span class="c1"># Mind that meomized parser calls will not appear in the history record!</span>
            <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">history_tracking__</span><span class="p">:</span>
                <span class="c1"># don&#39;t track returning parsers except in case an error has occurred</span>
                <span class="c1"># remaining = len(rest)</span>
                <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">moving_forward__</span> <span class="ow">or</span> <span class="p">(</span><span class="n">node</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">error_flag</span><span class="p">):</span>  <span class="c1"># node._errors</span>
                    <span class="n">record</span> <span class="o">=</span> <span class="n">HistoryRecord</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">call_stack__</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
                    <span class="n">grammar</span><span class="o">.</span><span class="n">history__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
                    <span class="c1"># print(record.stack, record.status, rest[:20].replace(&#39;\n&#39;, &#39;|&#39;))</span>
                <span class="n">grammar</span><span class="o">.</span><span class="n">moving_forward__</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">grammar</span><span class="o">.</span><span class="n">call_stack__</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">except</span> <span class="n">RecursionError</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)))])</span> <span class="o">+</span> <span class="s2">&quot; ...&quot;</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="s2">&quot;maximum recursion depth of parser reached; &quot;</span>
                           <span class="s2">&quot;potentially due to too many errors!&quot;</span><span class="p">)</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="n">EMPTY_STRING_VIEW</span>

        <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="n">rest</span>

    <span class="k">return</span> <span class="n">guarded_call</span>


<div class="viewcode-block" id="Parser"><a class="viewcode-back" href="../ModuleReference.html#parse.Parser">[docs]</a><span class="k">class</span> <span class="nc">Parser</span><span class="p">(</span><span class="n">ParserBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (Abstract) Base class for Parser combinator parsers. Any parser</span>
<span class="sd">    object that is actually used for parsing (i.e. no mock parsers)</span>
<span class="sd">    should should be derived from this class.</span>

<span class="sd">    Since parsers can contain other parsers (see classes UnaryOperator</span>
<span class="sd">    and NaryOperator) they form a cyclical directed graph. A root</span>
<span class="sd">    parser is a parser from which all other parsers can be reached.</span>
<span class="sd">    Usually, there is one root parser which serves as the starting</span>
<span class="sd">    point of the parsing process. When speaking of &quot;the root parser&quot;</span>
<span class="sd">    it is this root parser object that is meant.</span>

<span class="sd">    There are two different types of parsers:</span>

<span class="sd">    1. *Named parsers* for which a name is set in field `parser.name`.</span>
<span class="sd">       The results produced by these parsers can later be retrieved in</span>
<span class="sd">       the AST by the parser name.</span>

<span class="sd">    2. *Anonymous parsers* where the name-field just contains the empty</span>
<span class="sd">       string. AST-transformation of Anonymous parsers can be hooked</span>
<span class="sd">       only to their class name, and not to the individual parser.</span>

<span class="sd">    Parser objects are callable and parsing is done by calling a parser</span>
<span class="sd">    object with the text to parse.</span>

<span class="sd">    If the parser matches it returns a tuple consisting of a node</span>
<span class="sd">    representing the root of the concrete syntax tree resulting from the</span>
<span class="sd">    match as well as the substring `text[i:]` where i is the length of</span>
<span class="sd">    matched text (which can be zero in the case of parsers like</span>
<span class="sd">    `ZeroOrMore` or `Option`). If `i &gt; 0` then the parser has &quot;moved</span>
<span class="sd">    forward&quot;.</span>

<span class="sd">    If the parser does not match it returns `(None, text). **Note** that</span>
<span class="sd">    this is not the same as an empty match `(&quot;&quot;, text)`. Any empty match</span>
<span class="sd">    can for example be returned by the `ZeroOrMore`-parser in case the</span>
<span class="sd">    contained parser is repeated zero times.</span>

<span class="sd">    Attributes and Properties:</span>
<span class="sd">        visited:  Mapping of places this parser has already been to</span>
<span class="sd">                during the current parsing process onto the results the</span>
<span class="sd">                parser returned at the respective place. This dictionary</span>
<span class="sd">                is used to implement memoizing.</span>

<span class="sd">        recursion_counter:  Mapping of places to how often the parser</span>
<span class="sd">                has already been called recursively at this place. This</span>
<span class="sd">                is needed to implement left recursion. The number of</span>
<span class="sd">                calls becomes irrelevant once a resault has been memoized.</span>

<span class="sd">        cycle_detection:  The apply()-method uses this variable to make</span>
<span class="sd">                sure that one and the same function will not be applied</span>
<span class="sd">                (recursively) a second time, if it has already been</span>
<span class="sd">                applied to this parser.</span>

<span class="sd">        grammar:  A reference to the Grammar object to which the parser</span>
<span class="sd">                is attached.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ApplyFunc</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Parser&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># assert isinstance(name, str), str(name)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: &#39;Grammar&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># add &quot;aspect oriented&quot; wrapper around parser calls</span>
        <span class="c1"># for memoizing, left recursion and tracing</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Forward</span><span class="p">):</span>  <span class="c1"># should Forward-Parser no be guarded? Not sure...</span>
            <span class="n">guarded_parser_call</span> <span class="o">=</span> <span class="n">add_parser_guard</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span>
            <span class="c1"># The following check is necessary for classes that don&#39;t override</span>
            <span class="c1"># the __call__() method, because in these cases the non-overridden</span>
            <span class="c1"># __call__()-method would be substituted a second time!</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__call__</span><span class="o">.</span><span class="vm">__code__</span> <span class="o">!=</span> <span class="n">guarded_parser_call</span><span class="o">.</span><span class="vm">__code__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__call__</span> <span class="o">=</span> <span class="n">guarded_parser_call</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deepcopy method of the parser. Upon instantiation of a Grammar-</span>
<span class="sd">        object, parsers will be deep-copied to the Grammar object. If a</span>
<span class="sd">        derived parser-class changes the signature of the constructor,</span>
<span class="sd">        `__deepcopy__`-method must be replaced (i.e. overridden without</span>
<span class="sd">        calling the same method from the superclass) by the derived class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="Parser.reset"><a class="viewcode-back" href="../ModuleReference.html#parse.Parser.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes or resets any parser variables. If overwritten,</span>
<span class="sd">        the `reset()`-method of the parent class must be called from the</span>
<span class="sd">        `reset()`-method of the derived class.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># type: Dict[int, Tuple[Optional[Node], StringView]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recursion_counter</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># type: DefaultDict[int, int]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cycle_detection</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># type: Set[Callable]</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Applies the parser to the given `text` and returns a node with</span>
<span class="sd">        the results or None as well as the text at the position right behind</span>
<span class="sd">        the matching string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>  <span class="c1"># default behaviour: don&#39;t match</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Parser&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The + operator generates a series-parser that applies two</span>
<span class="sd">        parsers in sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Parser&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Alternative&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The | operator generates an alternative parser that applies</span>
<span class="sd">        the first parser and, if that does not match, the second parser.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Alternative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Grammar&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>

    <span class="nd">@grammar</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">:</span> <span class="s1">&#39;Grammar&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grammar_assigned_notifier</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">==</span> <span class="n">grammar</span><span class="p">,</span> \
                <span class="s2">&quot;Parser has already been assigned to a different Grammar object!&quot;</span>

    <span class="k">def</span> <span class="nf">_grammar_assigned_notifier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A function that notifies the parser object that it has been</span>
<span class="sd">        assigned to a grammar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Parser.apply"><a class="viewcode-back" href="../ModuleReference.html#parse.Parser.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">ApplyFunc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies function `func(parser)` recursively to this parser and all</span>
<span class="sd">        descendant parsers if any exist. The same function can never</span>
<span class="sd">        be applied twice between calls of the ``reset()``-method!</span>
<span class="sd">        Returns `True`, if function has been applied, `False` if function</span>
<span class="sd">        had been applied earlier already and thus has not been applied again.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycle_detection</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">,</span> <span class="s2">&quot;No calls to Parser.apply() during or &quot;</span> \
                                     <span class="s2">&quot;after ongoing parsing process. (Call Parser.reset() first.)&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cycle_detection</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span></div></div>


<div class="viewcode-block" id="mixin_comment"><a class="viewcode-back" href="../ModuleReference.html#parse.mixin_comment">[docs]</a><span class="k">def</span> <span class="nf">mixin_comment</span><span class="p">(</span><span class="n">whitespace</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a regular expression that merges comment and whitespace</span>
<span class="sd">    regexps. Thus comments cann occur whereever whitespace is allowed</span>
<span class="sd">    and will be skipped just as implicit whitespace.</span>

<span class="sd">    Note, that because this works on the level of regular expressions,</span>
<span class="sd">    nesting comments is not possible. It also makes it much harder to</span>
<span class="sd">    use directives inside comments (which isn&#39;t recommended, anyway).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wspc</span> <span class="o">=</span> <span class="s1">&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">whitespace</span> <span class="o">+</span> <span class="s1">&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">comment</span> <span class="o">+</span> <span class="n">whitespace</span> <span class="o">+</span> <span class="s1">&#39;)*)&#39;</span>
    <span class="k">return</span> <span class="n">wspc</span></div>


<div class="viewcode-block" id="UnknownParserError"><a class="viewcode-back" href="../ModuleReference.html#parse.UnknownParserError">[docs]</a><span class="k">class</span> <span class="nc">UnknownParserError</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;UnknownParserError is raised if a Grammer object is called with a</span>
<span class="sd">    parser that does not exist or if in the course of parsing a parser</span>
<span class="sd">    is reffered to that does not exist.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="Grammar"><a class="viewcode-back" href="../ModuleReference.html#parse.Grammar">[docs]</a><span class="k">class</span> <span class="nc">Grammar</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class Grammar directs the parsing process and stores global state</span>
<span class="sd">    information of the parsers, i.e. state information that is shared</span>
<span class="sd">    accross parsers.</span>

<span class="sd">    Grammars are basically collections of parser objects, which are</span>
<span class="sd">    connected to an instance object of class Grammar. There exist two</span>
<span class="sd">    ways of connecting parsers to grammar objects: Either by passing</span>
<span class="sd">    the root parser object to the constructor of a Grammar object</span>
<span class="sd">    (&quot;direct instantiation&quot;), or by assigning the root parser to the</span>
<span class="sd">    class variable &quot;root__&quot; of a descendant class of class Grammar.</span>

<span class="sd">    Example for direct instantiation of a grammar:</span>

<span class="sd">        &gt;&gt;&gt; number = RE(&#39;\d+&#39;) + RE(&#39;\.&#39;) + RE(&#39;\d+&#39;) | RE(&#39;\d+&#39;)</span>
<span class="sd">        &gt;&gt;&gt; number_parser = Grammar(number)</span>
<span class="sd">        &gt;&gt;&gt; number_parser(&quot;3.1416&quot;).content</span>
<span class="sd">        &#39;3.1416&#39;</span>

<span class="sd">    Collecting the parsers that define a grammar in a descendant class of</span>
<span class="sd">    class Grammar and assigning the named parsers to class variables</span>
<span class="sd">    rather than global variables has several advantages:</span>

<span class="sd">    1. It keeps the namespace clean.</span>

<span class="sd">    2. The parser names of named parsers do not need to be passed to the</span>
<span class="sd">       constructor of the Parser object explicitly, but it suffices to</span>
<span class="sd">       assign them to class variables, which results in better</span>
<span class="sd">       readability of the Python code.</span>

<span class="sd">    3. The parsers in the class do not necessarily need to be connected</span>
<span class="sd">       to one single root parser, which is helpful for testing and</span>
<span class="sd">       building up a parser successively of several components.</span>

<span class="sd">    As a consequence, though, it is highly recommended that a Grammar</span>
<span class="sd">    class should not define any other variables or methods with names</span>
<span class="sd">    that are legal parser names. A name ending with a double</span>
<span class="sd">    underscore &#39;__&#39; is *not* a legal parser name and can safely be</span>
<span class="sd">    used.</span>

<span class="sd">    Example::</span>

<span class="sd">        class Arithmetic(Grammar):</span>
<span class="sd">            # special fields for implicit whitespace and comment configuration</span>
<span class="sd">            COMMENT__ = r&#39;#.*(?:\n|$)&#39;  # Python style comments</span>
<span class="sd">            wspR__ = mixin_comment(whitespace=r&#39;[\t ]*&#39;, comment=COMMENT__)</span>

<span class="sd">            # parsers</span>
<span class="sd">            expression = Forward()</span>
<span class="sd">            INTEGER = RE(&#39;\\d+&#39;)</span>
<span class="sd">            factor = INTEGER | Token(&quot;(&quot;) + expression + Token(&quot;)&quot;)</span>
<span class="sd">            term = factor + ZeroOrMore((Token(&quot;*&quot;) | Token(&quot;/&quot;)) + factor)</span>
<span class="sd">            expression.set(term + ZeroOrMore((Token(&quot;+&quot;) | Token(&quot;-&quot;)) + term))</span>
<span class="sd">            root__ = expression</span>

<span class="sd">    Upon instantiation the parser objects are deep-copied to the</span>
<span class="sd">    Grammar object and assigned to object variables of the same name.</span>
<span class="sd">    Any parser that is directly assigned to a class variable is a</span>
<span class="sd">    &#39;named&#39; parser and its field `parser.name` contains the variable</span>
<span class="sd">    name after instantiation of the Grammar class. All other parsers,</span>
<span class="sd">    i.e. parsers that are defined within a `named` parser, remain</span>
<span class="sd">    &quot;anonymous parsers&quot; where `parser.name` is the empty string, unless</span>
<span class="sd">    a name has been passed explicitly upon instantiation.</span>
<span class="sd">    If one and the same parser is assigned to several class variables</span>
<span class="sd">    such as, for example the parser `expression` in the example above,</span>
<span class="sd">    the first name sticks.</span>

<span class="sd">    Grammar objects are callable. Calling a grammar object with a UTF-8</span>
<span class="sd">    encoded document, initiates the parsing of the document with the</span>
<span class="sd">    root parser. The return value is the concrete syntax tree. Grammar</span>
<span class="sd">    objects can be reused (i.e. called again) after parsing. Thus, it</span>
<span class="sd">    is not necessary to instantiate more than one Grammar object per</span>
<span class="sd">    thread.</span>

<span class="sd">    Grammar classes contain a few special class fields for implicit</span>
<span class="sd">    whitespace and comments that should be overwritten, if the defaults</span>
<span class="sd">    (no comments, horizontal right aligned whitespace) don&#39;t fit:</span>

<span class="sd">    Attributes:</span>
<span class="sd">        COMMENT__:  regular expression string for matching comments</span>

<span class="sd">        WSP__:   regular expression for whitespace and comments</span>

<span class="sd">        wspL__:  regular expression string for left aligned whitespace,</span>
<span class="sd">                 which either equals WSP__ or is empty.</span>

<span class="sd">        wspR__:  regular expression string for right aligned whitespace,</span>
<span class="sd">                 which either equals WSP__ or is empty.</span>

<span class="sd">        root__:  The root parser of the grammar. Theoretically, all parsers of the</span>
<span class="sd">                 grammar should be reachable by the root parser. However, for testing</span>
<span class="sd">                 of yet incomplete grammars class Grammar does not assume that this</span>
<span class="sd">                 is the case.</span>

<span class="sd">        parser_initializiation__:  Before the parser class (!) has been initialized,</span>
<span class="sd">                 which happens upon the first time it is instantiated (see</span>
<span class="sd">                 :func:_assign_parser_names()` for an explanation), this class</span>
<span class="sd">                 field contains a value other than &quot;done&quot;. A value of &quot;done&quot; indicates</span>
<span class="sd">                 that the class has already been initialized.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        all_parsers__:  A set of all parsers connected to this grammar object</span>

<span class="sd">        history_tracking__:  A flag indicating that the parsing history shall</span>
<span class="sd">                be tracked</span>

<span class="sd">        wsp_left_parser__:  A parser for the default left-adjacent-whitespace</span>
<span class="sd">                or the :class:zombie-parser if the</span>
<span class="sd">                default is empty. The default whitespace will be used by parsers</span>
<span class="sd">                :class:`Token` and, if no other parsers are passed to its constructor,</span>
<span class="sd">                by parser :class:`RE`.</span>

<span class="sd">        wsp_right_parser__: The same for the default right-adjacent-whitespace.</span>
<span class="sd">                Both wsp_left_parser__ and wsp_right_parser__ merely serve the</span>
<span class="sd">                purpose to avoid having to specify the default whitespace</span>
<span class="sd">                explicitly every time an :class:`RE`-parser-object is created.</span>

<span class="sd">        _dirty_flag__:  A flag indicating that the Grammar has been called at</span>
<span class="sd">                least once so that the parsing-variables need to be reset</span>
<span class="sd">                when it is called again.</span>

<span class="sd">        document__:  the text that has most recently been parsed or that is</span>
<span class="sd">                currently being parsed.</span>

<span class="sd">        document_length__:  the length of the document.</span>

<span class="sd">        document_lbreaks__:  list of linebreaks within the document, starting</span>
<span class="sd">                with -1 and ending with EOF. This helps generating line</span>
<span class="sd">                and column number for history recording and will only be</span>
<span class="sd">                initialized if :attr:`history_tracking__` is true.</span>

<span class="sd">        _reversed__:  the same text in reverse order - needed by the `Lookbehind`-</span>
<span class="sd">                parsers.</span>

<span class="sd">        variables__:  A mapping for variable names to a stack of their respective</span>
<span class="sd">                string values - needed by the :class:`Capture`-, :class:`Retrieve`-</span>
<span class="sd">                and :class:`Pop`-parsers.</span>

<span class="sd">        rollback__:  A list of tuples (location, rollback-function) that are</span>
<span class="sd">                deposited by the :class:`Capture`- and :class:`Pop`-parsers.</span>
<span class="sd">                If the parsing process reaches a dead end then all</span>
<span class="sd">                rollback-functions up to the point to which it retreats will be</span>
<span class="sd">                called and the state of the variable stack restored accordingly.</span>

<span class="sd">        last_rb__loc__:  The last, i.e. most advanced location in the text</span>
<span class="sd">                where a variable changing operation occurred. If the parser</span>
<span class="sd">                backtracks to a location at or before last_rb__loc__ (i.e.</span>
<span class="sd">                location &lt;= last_rb__loc__) then a rollback of all variable</span>
<span class="sd">                changing operations is necessary that occurred after the</span>
<span class="sd">                location to which the parser backtracks. This is done by</span>
<span class="sd">                calling method :func:`rollback_to__(location)`.</span>

<span class="sd">        call_stack__:  A stack of all parsers that have been called. This</span>
<span class="sd">                is required for recording the parser history (for debugging)</span>
<span class="sd">                and, eventually, i.e. one day in the future, for tracing through</span>
<span class="sd">                the parsing process.</span>

<span class="sd">        history__:  A list of parser-call-stacks. A parser-call-stack is</span>
<span class="sd">                appended to the list each time a parser either matches, fails</span>
<span class="sd">                or if a parser-error occurs.</span>

<span class="sd">        moving_forward__: This flag indicates that the parsing process is currently</span>
<span class="sd">                moving forward . It is needed to reduce noise in history recording</span>
<span class="sd">                and should not be considered as having a valid value if history</span>
<span class="sd">                recording is turned off! (See :func:`add_parser_guard` and its local</span>
<span class="sd">                function :func:`guarded_call`)</span>

<span class="sd">        recursion_locations__:  Stores the locations where left recursion was</span>
<span class="sd">                detected. Needed to provide minimal memoization for the left</span>
<span class="sd">                recursion detection algorithm, but, strictly speaking, superfluous</span>
<span class="sd">                if full memoization is enabled. (See :func:`add_parser_guard` and its</span>
<span class="sd">                local function :func:`guarded_call`)</span>

<span class="sd">        memoization__:  Turns full memoization on or off. Turning memoization off</span>
<span class="sd">                results in less memory usage and sometimes reduced parsing time.</span>
<span class="sd">                In some situations it may drastically increase parsing time, so</span>
<span class="sd">                it is safer to leave it on. (Default: on)</span>

<span class="sd">        left_recursion_handling__:  Turns left recursion handling on or off.</span>
<span class="sd">                If turned off, a recursion error will result in case of left</span>
<span class="sd">                recursion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">root__</span> <span class="o">=</span> <span class="n">ZOMBIE_PARSER</span>  <span class="c1"># type: ParserBase</span>
    <span class="c1"># root__ must be overwritten with the root-parser by grammar subclass</span>
    <span class="n">parser_initialization__</span> <span class="o">=</span> <span class="s2">&quot;pending&quot;</span>  <span class="c1"># type: str</span>
    <span class="c1"># some default values</span>
    <span class="n">COMMENT__</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;</span>  <span class="c1"># type: str  # r&#39;#.*(?:\n|$)&#39;</span>
    <span class="n">WSP__</span> <span class="o">=</span> <span class="n">mixin_comment</span><span class="p">(</span><span class="n">whitespace</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;[\t ]*&#39;</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">COMMENT__</span><span class="p">)</span>  <span class="c1"># type: str</span>
    <span class="n">wspL__</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>     <span class="c1"># type: str</span>
    <span class="n">wspR__</span> <span class="o">=</span> <span class="n">WSP__</span>  <span class="c1"># type: str</span>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_assign_parser_names__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the `parser.name` fields of those</span>
<span class="sd">        Parser objects that are directly assigned to a class field with</span>
<span class="sd">        the field&#39;s name, e.g.::</span>

<span class="sd">            class Grammar(Grammar):</span>
<span class="sd">                ...</span>
<span class="sd">                symbol = RE(&#39;(?!\\d)\\w+&#39;)</span>

<span class="sd">        After the call of this method symbol.name == &quot;symbol&quot;</span>
<span class="sd">        holds. Names assigned via the ``name``-parameter of the</span>
<span class="sd">        constructor will not be overwritten. Parser names starting or</span>
<span class="sd">        ending with a double underscore like ``root__`` will be</span>
<span class="sd">        ignored. See :func:`sane_parser_name()`</span>

<span class="sd">        This is done only once, upon the first instantiation of the</span>
<span class="sd">        grammar class!</span>

<span class="sd">        Attention: If there exists more than one reference to the same</span>
<span class="sd">        parser, only the first one will be chosen for python versions</span>
<span class="sd">        greater or equal 3.6.  For python version &lt;= 3.5 an arbitrarily</span>
<span class="sd">        selected reference will be chosen. See PEP 520</span>
<span class="sd">        (www.python.org/dev/peps/pep-0520/) for an explanation of why.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">parser_initialization__</span> <span class="o">!=</span> <span class="s2">&quot;done&quot;</span><span class="p">:</span>
            <span class="n">cdict</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span>
            <span class="k">for</span> <span class="n">entry</span><span class="p">,</span> <span class="n">parser</span> <span class="ow">in</span> <span class="n">cdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">Parser</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sane_parser_name</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">parser</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                        <span class="n">parser</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">entry</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">Forward</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">parser</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">_name</span><span class="p">):</span>
                        <span class="n">parser</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">entry</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">parser_initialization__</span> <span class="o">=</span> <span class="s2">&quot;done&quot;</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Parser</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># if not hasattr(self.__class__, &#39;parser_initialization__&#39;):</span>
        <span class="c1">#     self.__class__.parser_initialization__ = &quot;pending&quot;</span>
        <span class="c1"># if not hasattr(self.__class__, &#39;wspL__&#39;):</span>
        <span class="c1">#     self.wspL__ = &#39;&#39;</span>
        <span class="c1"># if not hasattr(self.__class__, &#39;wspR__&#39;):</span>
        <span class="c1">#     self.wspR__ = &#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_parsers__</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>             <span class="c1"># type: Set[ParserBase]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_flag__</span> <span class="o">=</span> <span class="kc">False</span>             <span class="c1"># type: bool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history_tracking__</span> <span class="o">=</span> <span class="kc">False</span>        <span class="c1"># type: bool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memoization__</span> <span class="o">=</span> <span class="kc">True</span>              <span class="c1"># type: bool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_recursion_handling__</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># type: bool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset__</span><span class="p">()</span>

        <span class="c1"># prepare parsers in the class, first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_parser_names__</span><span class="p">()</span>

        <span class="c1"># then deep-copy the parser tree from class to instance;</span>
        <span class="c1"># parsers not connected to the root object will be copied later</span>
        <span class="c1"># on demand (see Grammar.__getitem__()). Usually, the need to</span>
        <span class="c1"># do so only arises during testing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root__</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">root__</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wspL__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wsp_left_parser__</span> <span class="o">=</span> <span class="n">Whitespace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wspL__</span><span class="p">)</span>  <span class="c1"># type: ParserBase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wsp_left_parser__</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_parsers__</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wsp_left_parser__</span><span class="p">)</span>  <span class="c1"># don&#39;t you forget about me...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wsp_left_parser__</span> <span class="o">=</span> <span class="n">ZOMBIE_PARSER</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wspR__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wsp_right_parser__</span> <span class="o">=</span> <span class="n">Whitespace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wspR__</span><span class="p">)</span>  <span class="c1"># type: ParserBase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wsp_right_parser__</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_parsers__</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wsp_right_parser__</span><span class="p">)</span>  <span class="c1"># don&#39;t you forget about me...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wsp_right_parser__</span> <span class="o">=</span> <span class="n">ZOMBIE_PARSER</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root__</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_parser__</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">parser_template</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parser_template</span><span class="p">:</span>
                <span class="c1"># add parser to grammar object on the fly...</span>
                <span class="n">parser</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">parser_template</span><span class="p">)</span>
                <span class="n">parser</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_parser__</span><span class="p">)</span>
                <span class="c1"># assert self[key] == parser</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">UnknownParserError</span><span class="p">(</span><span class="s1">&#39;Unknown parser &quot;</span><span class="si">%s</span><span class="s1">&quot; !&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_reset__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">document__</span> <span class="o">=</span> <span class="n">EMPTY_STRING_VIEW</span>   <span class="c1"># type: StringView</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reversed__</span> <span class="o">=</span> <span class="n">EMPTY_STRING_VIEW</span>  <span class="c1"># type: StringView</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">document_length__</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c1"># type: int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">document_lbreaks__</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># type: List[int]</span>
        <span class="c1"># variables stored and recalled by Capture and Retrieve parsers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables__</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:[])</span>  <span class="c1"># type: DefaultDict[str, List[str]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rollback__</span> <span class="o">=</span> <span class="p">[]</span>                  <span class="c1"># type: List[Tuple[int, Callable]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rb__loc__</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>              <span class="c1"># type: int</span>
        <span class="c1"># support for call stack tracing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_stack__</span> <span class="o">=</span> <span class="p">[]</span>                <span class="c1"># type: List[Parser]</span>
        <span class="c1"># snapshots of call stacks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history__</span> <span class="o">=</span> <span class="p">[]</span>                   <span class="c1"># type: List[HistoryRecord]</span>
        <span class="c1"># also needed for call stack tracing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_forward__</span> <span class="o">=</span> <span class="kc">False</span>         <span class="c1"># type: bool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recursion_locations__</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>    <span class="c1"># type: Set[int]</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StringView</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a reversed version of the currently parsed document. As</span>
<span class="sd">        about the only case where this is needed is the Lookbehind-parser,</span>
<span class="sd">        this is done lazily.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reversed__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reversed__</span> <span class="o">=</span> <span class="n">StringView</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">document__</span><span class="o">.</span><span class="n">text</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reversed__</span>


    <span class="k">def</span> <span class="nf">_add_parser__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the particular copy of the parser object to this</span>
<span class="sd">        particular instance of Grammar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parser</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="c1"># prevent overwriting instance variables or parsers of a different class</span>
            <span class="k">assert</span> <span class="n">parser</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">or</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">parser</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">parser</span><span class="o">.</span><span class="vm">__class__</span><span class="p">),</span> \
                <span class="p">(</span><span class="s1">&#39;Cannot add parser &quot;</span><span class="si">%s</span><span class="s1">&quot; because a field with the same name &#39;</span>
                 <span class="s1">&#39;already exists in grammar object!&#39;</span> <span class="o">%</span> <span class="n">parser</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_parsers__</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span>


    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">document</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start_parser</span><span class="o">=</span><span class="s2">&quot;root__&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses a document with with parser-combinators.</span>

<span class="sd">        Args:</span>
<span class="sd">            document (str): The source text to be parsed.</span>
<span class="sd">            start_parser (str): The name of the parser with which to</span>
<span class="sd">                start. This is useful for testing particular parsers</span>
<span class="sd">                (i.e. particular parts of the EBNF-Grammar.)</span>
<span class="sd">        Returns:</span>
<span class="sd">            Node: The root node ot the parse tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">tail_pos</span><span class="p">(</span><span class="n">predecessors</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Adds the position after the last node in the list of</span>
<span class="sd">            predecessors to the node.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">predecessors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">predecessors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">predecessors</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="c1"># assert isinstance(document, str), type(document)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root__</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_flag__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset__</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_parsers__</span><span class="p">:</span>
                <span class="n">parser</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_flag__</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history_tracking__</span> <span class="o">=</span> <span class="n">is_logging</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">document__</span> <span class="o">=</span> <span class="n">StringView</span><span class="p">(</span><span class="n">document</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">document_length__</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">document__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">document_lbreaks__</span> <span class="o">=</span> <span class="n">linebreaks</span><span class="p">(</span><span class="n">document</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">history_tracking__</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rb__loc__</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># rollback location</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">start_parser</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_parser</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">start_parser</span>
        <span class="k">assert</span> <span class="n">parser</span><span class="o">.</span><span class="n">grammar</span> <span class="o">==</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Cannot run parsers from a different grammar object!&quot;</span> \
                                       <span class="s2">&quot; </span><span class="si">%s</span><span class="s2"> vs. </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">grammar</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[Node]</span>
        <span class="n">stitches</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[Node]</span>
        <span class="n">rest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">document__</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rest</span><span class="p">:</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">init_pos</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="s1">&#39;Parser &quot;</span><span class="si">%s</span><span class="s1">&quot; did not match empty document.&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">parser</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">rest</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stitches</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MAX_DROPOUTS</span><span class="p">:</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">parser</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rest</span><span class="p">:</span>
                <span class="n">fwd</span> <span class="o">=</span> <span class="n">rest</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
                <span class="n">skip</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span><span class="p">[:</span><span class="n">fwd</span><span class="p">],</span> <span class="n">rest</span><span class="p">[</span><span class="n">fwd</span><span class="p">:]</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">error_msg</span> <span class="o">=</span> <span class="s1">&#39;Parser did not match! Invalid source file?&#39;</span> \
                                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">    Most advanced: </span><span class="si">%s</span><span class="se">\n</span><span class="s1">    Last match:    </span><span class="si">%s</span><span class="s1">;&#39;</span> <span class="o">%</span> \
                                <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">HistoryRecord</span><span class="o">.</span><span class="n">most_advanced_match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history__</span><span class="p">)),</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">HistoryRecord</span><span class="o">.</span><span class="n">last_match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history__</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stitches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                    <span class="n">error_msg</span> <span class="o">=</span> <span class="s2">&quot;Parser stopped before end&quot;</span> <span class="o">+</span> \
                                <span class="p">((</span><span class="s2">&quot;! trying to recover&quot;</span> <span class="o">+</span>
                                  <span class="p">(</span><span class="s2">&quot; but stopping history recording at this point.&quot;</span>
                                   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">history_tracking__</span> <span class="k">else</span> <span class="s2">&quot;...&quot;</span><span class="p">))</span>
                                 <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stitches</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MAX_DROPOUTS</span>
                                 <span class="k">else</span> <span class="s2">&quot; too often! Terminating parser.&quot;</span><span class="p">)</span>
                <span class="n">stitches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip</span><span class="p">)</span><span class="o">.</span><span class="n">init_pos</span><span class="p">(</span><span class="n">tail_pos</span><span class="p">(</span><span class="n">stitches</span><span class="p">)))</span>
                <span class="n">stitches</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">history_tracking__</span><span class="p">:</span>
                    <span class="c1"># # some parsers may have matched and left history records with nodes != None.</span>
                    <span class="c1"># # Because these are not connected to the stitched root node, their pos-</span>
                    <span class="c1"># # properties will not be initialized by setting the root node&#39;s pos property</span>
                    <span class="c1"># # to zero. Therefore, their pos properties need to be initialized here</span>
                    <span class="c1"># for record in self.history__:</span>
                    <span class="c1">#     if record.node and record.node._pos &lt; 0:</span>
                    <span class="c1">#         record.node.init_pos(0)</span>
                    <span class="n">record</span> <span class="o">=</span> <span class="n">HistoryRecord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">call_stack__</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">stitches</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rest</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">history__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
                    <span class="c1"># stop history tracking when parser returned too early</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">history_tracking__</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">stitches</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rest</span><span class="p">:</span>
                <span class="n">stitches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">rest</span><span class="p">))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">stitches</span><span class="p">))</span><span class="o">.</span><span class="n">init_pos</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables__</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">error_str</span> <span class="o">=</span> <span class="s2">&quot;Capture-retrieve-stack not empty after end of parsing: &quot;</span> \
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables__</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="c1"># add another child node at the end to ensure that the position</span>
                    <span class="c1"># of the error will be the end of the text. Otherwise, the error</span>
                    <span class="c1"># message above (&quot;...after end of parsing&quot;) would appear illogical.</span>
                    <span class="n">error_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">ZOMBIE_PARSER</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">init_pos</span><span class="p">(</span><span class="n">tail_pos</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
                    <span class="n">error_node</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">children</span> <span class="o">+</span> <span class="p">(</span><span class="n">error_node</span><span class="p">,)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span>
        <span class="c1"># result.pos = 0  # calculate all positions</span>
        <span class="c1"># result.collect_errors(self.document__)</span>
        <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="Grammar.push_rollback__"><a class="viewcode-back" href="../ModuleReference.html#parse.Grammar.push_rollback__">[docs]</a>    <span class="k">def</span> <span class="nf">push_rollback__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a rollback function that either removes or re-adds</span>
<span class="sd">        values on the variable stack (`self.variables`) that have been</span>
<span class="sd">        added (or removed) by Capture or Pop Parsers, the results of</span>
<span class="sd">        which have been dismissed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rollback__</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">location</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rb__loc__</span> <span class="o">=</span> <span class="n">location</span></div>


<div class="viewcode-block" id="Grammar.rollback_to__"><a class="viewcode-back" href="../ModuleReference.html#parse.Grammar.rollback_to__">[docs]</a>    <span class="k">def</span> <span class="nf">rollback_to__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rolls back the variable stacks (`self.variables`) to its</span>
<span class="sd">        state at an earlier location in the parsed document.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollback__</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollback__</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">location</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">rollback_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollback__</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># assert not loc &gt; self.last_rb__loc__, \</span>
            <span class="c1">#     &quot;Rollback confusion: line %i, col %i &lt; line %i, col %i&quot; % \</span>
            <span class="c1">#     (*line_col(self.document__, len(self.document__) - loc),</span>
            <span class="c1">#      *line_col(self.document__, len(self.document__) - self.last_rb__loc__))</span>
            <span class="n">rollback_func</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rb__loc__</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollback__</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollback__</span> \
            <span class="k">else</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">document__</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">dsl_error_msg</span><span class="p">(</span><span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">error_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an error message for errors in the parser configuration,</span>
<span class="sd">    e.g. errors that result in infinite loops.</span>

<span class="sd">    Args:</span>
<span class="sd">        parser (Parser):  The parser where the error was noticed. Note</span>
<span class="sd">            that this is not necessarily the parser that caused the</span>
<span class="sd">            error but only where the error became apparent.</span>
<span class="sd">        error_str (str):  A short string describing the error.</span>
<span class="sd">    Returns:</span>
<span class="sd">        str: An error message including the call stack if history</span>
<span class="sd">        tacking has been turned in the grammar object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DSL parser specification error:&quot;</span><span class="p">,</span> <span class="n">error_str</span><span class="p">,</span> <span class="s1">&#39;Caught by parser &quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">parser</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">parser</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">history__</span><span class="p">:</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Call stack:&quot;</span><span class="p">,</span> <span class="n">parser</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">history__</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stack</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Enable history tracking in Grammar object to display call stack.&quot;</span><span class="p">])</span>
    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># Token and Regular Expression parser classes (i.e. leaf classes)</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>


<div class="viewcode-block" id="PreprocessorToken"><a class="viewcode-back" href="../ModuleReference.html#parse.PreprocessorToken">[docs]</a><span class="k">class</span> <span class="nc">PreprocessorToken</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses tokens that have been inserted by a preprocessor.</span>

<span class="sd">    Preprocessors can generate Tokens with the ``make_token``-function.</span>
<span class="sd">    These tokens start and end with magic characters that can only be</span>
<span class="sd">    matched by the PreprocessorToken Parser. Such tokens can be used to</span>
<span class="sd">    insert BEGIN - END delimiters at the beginning or ending of a</span>
<span class="sd">    quoted block, for example.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">token</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">RX_TOKEN_NAME</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">BEGIN_TOKEN</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">END_TOKEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span>
                    <span class="s1">&#39;END_TOKEN delimiter missing from preprocessor token. &#39;</span>
                    <span class="s1">&#39;(Most likely due to a preprocessor bug!)&#39;</span><span class="p">)</span>  <span class="c1"># type: Node</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">elif</span> <span class="n">end</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span>
                    <span class="s1">&#39;Preprocessor-token cannot have zero length. &#39;</span>
                    <span class="s1">&#39;(Most likely due to a preprocessor bug!)&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">elif</span> <span class="n">text</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">BEGIN_TOKEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
                <span class="n">node</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span>
                    <span class="s1">&#39;Preprocessor-tokens must not be nested or contain &#39;</span>
                    <span class="s1">&#39;BEGIN_TOKEN delimiter as part of their argument. &#39;</span>
                    <span class="s1">&#39;(Most likely due to a preprocessor bug!)&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span><span class="n">end</span><span class="p">]),</span> <span class="n">text</span><span class="p">[</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span></div>


<span class="k">class</span> <span class="nc">PlainText</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses plain text strings. (Could be done by RegExp as well, but is faster.)</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; while_token = PlainText(&quot;while&quot;)</span>
<span class="sd">        &gt;&gt;&gt; Grammar(while_token)(&quot;while&quot;).content</span>
<span class="sd">        &#39;while&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">text</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">:]</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>


<div class="viewcode-block" id="RegExp"><a class="viewcode-back" href="../ModuleReference.html#parse.RegExp">[docs]</a><span class="k">class</span> <span class="nc">RegExp</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Regular expression parser.</span>

<span class="sd">    The RegExp-parser parses text that matches a regular expression.</span>
<span class="sd">    RegExp can also be considered as the &quot;atomic parser&quot;, because all</span>
<span class="sd">    other parsers delegate part of the parsing job to other parsers,</span>
<span class="sd">    but do not match text directly.</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; word = RegExp(r&#39;\w+&#39;)</span>
<span class="sd">        &gt;&gt;&gt; Grammar(word)(&quot;Haus&quot;).content</span>
<span class="sd">        &#39;Haus&#39;</span>

<span class="sd">    EBNF-Notation:  ``/ ... /``</span>

<span class="sd">    EBNF-Example:   ``word = /\w+/``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regexp</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regexp</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regexp</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">regexp</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="c1"># `regex` supports deep copies, but not `re`</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">regexp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regexp</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">regexp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regexp</span><span class="o">.</span><span class="n">pattern</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">regexp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regexp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">capture</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
            <span class="c1"># regular expression must never match preprocessor-tokens!</span>
            <span class="c1"># TODO: Find a better solution here? e.g. static checking/re-mangling at compile time</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">capture</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">BEGIN_TOKEN</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">capture</span> <span class="o">=</span> <span class="n">capture</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capture</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">text</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">escape_control_characters</span><span class="p">(</span><span class="s1">&#39;/</span><span class="si">%s</span><span class="s1">/&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">regexp</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">Whitespace</span><span class="p">(</span><span class="n">RegExp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An variant of RegExp that signifies through its class name that it</span>
<span class="sd">    is a RegExp-parser for whitespace.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">WHITESPACE_PTYPE</span> <span class="o">==</span> <span class="s2">&quot;:Whitespace&quot;</span>


<div class="viewcode-block" id="RE"><a class="viewcode-back" href="../ModuleReference.html#parse.RE">[docs]</a><span class="k">class</span> <span class="nc">RE</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Regular Expressions with optional leading or trailing whitespace.</span>

<span class="sd">    The RE-parser parses pieces of text that match a given regular</span>
<span class="sd">    expression. Other than the ``RegExp``-Parser it can also skip</span>
<span class="sd">    &quot;implicit whitespace&quot; before or after the matched text.</span>

<span class="sd">    The whitespace is in turn defined by a regular expression. It should</span>
<span class="sd">    be made sure that this expression also matches the empty string,</span>
<span class="sd">    e.g. use r&#39;\s*&#39; or r&#39;[\t ]+&#39;, but not r&#39;\s+&#39;. If the respective</span>
<span class="sd">    parameters in the constructor are set to ``None`` the default</span>
<span class="sd">    whitespace expression from the Grammar object will be used.</span>

<span class="sd">    Example (allowing whitespace on the right hand side, but not on</span>
<span class="sd">    the left hand side of a regular expression)::</span>

<span class="sd">        &gt;&gt;&gt; word = RE(r&#39;\w+&#39;, wR=r&#39;\s*&#39;)</span>
<span class="sd">        &gt;&gt;&gt; parser = Grammar(word)</span>
<span class="sd">        &gt;&gt;&gt; result = parser(&#39;Haus &#39;)</span>
<span class="sd">        &gt;&gt;&gt; result.content</span>
<span class="sd">        &#39;Haus &#39;</span>
<span class="sd">        &gt;&gt;&gt; result.structure</span>
<span class="sd">        &#39;(:RE (:RegExp &quot;Haus&quot;) (:Whitespace &quot; &quot;))&#39;</span>
<span class="sd">        &gt;&gt;&gt; str(parser(&#39; Haus&#39;))</span>
<span class="sd">        &#39; &lt;&lt;&lt; Error on &quot; Haus&quot; | Parser did not match! Invalid source file?\n    Most advanced: None\n    Last match:    None; &gt;&gt;&gt; &#39;</span>

<span class="sd">    EBNF-Notation:  ``/ ... /~`  or  `~/ ... /`  or  `~/ ... /~``</span>

<span class="sd">    EBNF-Example:   ``word = /\w+/~``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regexp</span><span class="p">,</span> <span class="n">wL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constructor for class RE.</span>

<span class="sd">        Args:</span>
<span class="sd">            regexp (str or regex object):  The regular expression to be</span>
<span class="sd">                used for parsing.</span>
<span class="sd">            wL (str or regexp):  Left whitespace regular expression,</span>
<span class="sd">                i.e. either ``None``, the empty string or a regular</span>
<span class="sd">                expression (e.g. &quot;\s*&quot;) that defines whitespace. An</span>
<span class="sd">                empty string means no whitespace will be skipped,</span>
<span class="sd">                ``None`` means that the default whitespace will be</span>
<span class="sd">                used.</span>
<span class="sd">            wR (str or regexp):  Right whitespace regular expression.</span>
<span class="sd">                See above.</span>
<span class="sd">            name:  The optional name of the parser.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_wsl</span> <span class="o">=</span> <span class="n">wL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_wsr</span> <span class="o">=</span> <span class="n">wR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wsp_left</span> <span class="o">=</span> <span class="n">Whitespace</span><span class="p">(</span><span class="n">wL</span><span class="p">)</span> <span class="k">if</span> <span class="n">wL</span> <span class="k">else</span> <span class="n">ZOMBIE_PARSER</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wsp_right</span> <span class="o">=</span> <span class="n">Whitespace</span><span class="p">(</span><span class="n">wR</span><span class="p">)</span> <span class="k">if</span> <span class="n">wR</span> <span class="k">else</span> <span class="n">ZOMBIE_PARSER</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_main_parser</span><span class="p">(</span><span class="n">regexp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">regexp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">regexp</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">regexp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">regexp</span><span class="o">.</span><span class="n">pattern</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">regexp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_wsl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_wsr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="c1"># assert self.main.regexp.pattern != &quot;@&quot;</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="n">text</span>    <span class="c1"># type: StringView</span>
        <span class="n">wsl</span><span class="p">,</span> <span class="n">txt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wsp_left</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="n">main</span><span class="p">,</span> <span class="n">txt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">main</span><span class="p">:</span>
            <span class="n">wsr</span><span class="p">,</span> <span class="n">txt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wsp_right</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nd</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="p">(</span><span class="n">wsl</span><span class="p">,</span> <span class="n">main</span><span class="p">,</span> <span class="n">wsr</span><span class="p">)</span> <span class="k">if</span> <span class="n">nd</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">),</span> <span class="n">txt</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">wsl</span> <span class="o">=</span> <span class="s1">&#39;~&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wsp_left</span> <span class="o">!=</span> <span class="n">ZOMBIE_PARSER</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">wsr</span> <span class="o">=</span> <span class="s1">&#39;~&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wsp_right</span> <span class="o">!=</span> <span class="n">ZOMBIE_PARSER</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="k">return</span> <span class="n">wsl</span> <span class="o">+</span> <span class="s1">&#39;/</span><span class="si">%s</span><span class="s1">/&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">regexp</span><span class="o">.</span><span class="n">pattern</span> <span class="o">+</span> <span class="n">wsr</span>

    <span class="k">def</span> <span class="nf">_grammar_assigned_notifier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">:</span>
            <span class="c1"># use default whitespace parsers if not otherwise specified</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_wsl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wsp_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">wsp_left_parser__</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_wsr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wsp_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">wsp_right_parser__</span>

<div class="viewcode-block" id="RE.apply"><a class="viewcode-back" href="../ModuleReference.html#parse.RE.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Parser</span><span class="o">.</span><span class="n">ApplyFunc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_wsl</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wsp_left</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_wsr</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wsp_right</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="RE.create_main_parser"><a class="viewcode-back" href="../ModuleReference.html#parse.RE.create_main_parser">[docs]</a>    <span class="k">def</span> <span class="nf">create_main_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Parser</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates the main parser of this compound parser. Can be overridden.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RegExp</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Token"><a class="viewcode-back" href="../ModuleReference.html#parse.Token">[docs]</a><span class="k">class</span> <span class="nc">Token</span><span class="p">(</span><span class="n">RE</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class Token parses simple strings. Any regular regular expression</span>
<span class="sd">    commands will be interpreted as simple sequence of characters.</span>

<span class="sd">    Other than that class Token is essentially a renamed version of</span>
<span class="sd">    class RE. Because tokens often have a particular semantic different</span>
<span class="sd">    from other REs, parsing them with a separate parser class allows to</span>
<span class="sd">    distinguish them by their parser type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">TOKEN_PTYPE</span> <span class="o">==</span> <span class="s2">&quot;:Token&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">token</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">wL</span><span class="p">,</span> <span class="n">wR</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_wsl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_wsr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>

<div class="viewcode-block" id="Token.create_main_parser"><a class="viewcode-back" href="../ModuleReference.html#parse.Token.create_main_parser">[docs]</a>    <span class="k">def</span> <span class="nf">create_main_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Parser</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PlainText</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span></div></div>


<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># Containing parser classes, i.e. parsers that contain other parsers</span>
<span class="c1"># to which they delegate parsing</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>


<span class="k">class</span> <span class="nc">UnaryOperator</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of all unary parser operators, i.e. parser that contains</span>
<span class="sd">    one and only one other parser, like the optional parser for example.</span>

<span class="sd">    The UnaryOperator base class supplies __deepcopy__ and apply</span>
<span class="sd">    methods for unary parser operators. The __deepcopy__ method needs</span>
<span class="sd">    to be overwritten, however, if the constructor of a derived class</span>
<span class="sd">    has additional parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UnaryOperator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">Parser</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">parser</span>  <span class="c1"># type: Parser</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Parser</span><span class="o">.</span><span class="n">ApplyFunc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">NaryOperator</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of all Nnary parser operators, i.e. parser that</span>
<span class="sd">    contains one or more other parsers, like the alternative</span>
<span class="sd">    parser for example.</span>

<span class="sd">    The NnaryOperator base class supplies __deepcopy__ and apply methods</span>
<span class="sd">    for unary parser operators. The __deepcopy__ method needs to be</span>
<span class="sd">    overwritten, however, if the constructor of a derived class has</span>
<span class="sd">    additional parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parsers</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">Parser</span><span class="p">)</span> <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="n">parsers</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">parsers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span> <span class="o">=</span> <span class="n">parsers</span>  <span class="c1"># type: Tuple[Parser, ...]</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">parsers</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">parsers</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Parser</span><span class="o">.</span><span class="n">ApplyFunc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">:</span>
                <span class="n">parser</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="Option"><a class="viewcode-back" href="../ModuleReference.html#parse.Option">[docs]</a><span class="k">class</span> <span class="nc">Option</span><span class="p">(</span><span class="n">UnaryOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parser ``Option`` always matches, even if its child-parser</span>
<span class="sd">    did not match.</span>

<span class="sd">    If the child-parser did not match ``Option`` returns a node</span>
<span class="sd">    with no content and does not move forward in the text.</span>

<span class="sd">    If the child-parser did match, ``Option`` returns the a node</span>
<span class="sd">    with the node returnd by the child-parser as its single</span>
<span class="sd">    child and the text at the position where the child-parser</span>
<span class="sd">    left it.</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; number = Option(Token(&#39;-&#39;)) + RegExp(r&#39;\d+&#39;) + Option(RegExp(r&#39;\.\d+&#39;))</span>
<span class="sd">        &gt;&gt;&gt; Grammar(number)(&#39;3.14159&#39;).content</span>
<span class="sd">        &#39;3.14159&#39;</span>
<span class="sd">        &gt;&gt;&gt; Grammar(number)(&#39;3.14159&#39;).structure</span>
<span class="sd">        &#39;(:Series (:Option) (:RegExp &quot;3&quot;) (:Option (:RegExp &quot;.14159&quot;)))&#39;</span>
<span class="sd">        &gt;&gt;&gt; Grammar(number)(&#39;-1&#39;).content</span>
<span class="sd">        &#39;-1&#39;</span>

<span class="sd">    EBNF-Notation: ``[ ... ]``</span>

<span class="sd">    EBNF-Example:  ``number = [&quot;-&quot;]  /\d+/  [ /\.\d+/ ]``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="c1"># assert isinstance(parser, Parser)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">Option</span><span class="p">),</span> \
            <span class="s2">&quot;Redundant nesting of options: </span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="c1"># assert not isinstance(parser, Required), \</span>
        <span class="c1">#     &quot;Nesting options with required elements is contradictory: &quot; \</span>
        <span class="c1">#     &quot;%s(%s)&quot; % (str(name), str(parser.name))</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">),</span> <span class="n">text</span>
        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">()),</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="n">Alternative</span><span class="p">)</span>
                      <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span></div>


<div class="viewcode-block" id="ZeroOrMore"><a class="viewcode-back" href="../ModuleReference.html#parse.ZeroOrMore">[docs]</a><span class="k">class</span> <span class="nc">ZeroOrMore</span><span class="p">(</span><span class="n">Option</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ZeroOrMore` applies a parser repeatedly as long as this parser</span>
<span class="sd">    matches. Like `Option` the `ZeroOrMore` parser always matches. In</span>
<span class="sd">    case of zero repetitions, the empty match `((), text)` is returned.</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; sentence = ZeroOrMore(RE(r&#39;\w+,?&#39;)) + Token(&#39;.&#39;)</span>
<span class="sd">        &gt;&gt;&gt; Grammar(sentence)(&#39;Wo viel der Weisheit, da auch viel des Grämens.&#39;).content</span>
<span class="sd">        &#39;Wo viel der Weisheit, da auch viel des Grämens.&#39;</span>
<span class="sd">        &gt;&gt;&gt; Grammar(sentence)(&#39;.&#39;).content  # an empty sentence also matches</span>
<span class="sd">        &#39;.&#39;</span>

<span class="sd">    EBNF-Notation: ``{ ... }``</span>

<span class="sd">    EBNF-Example:  ``sentence = { /\w+,?/ } &quot;.&quot;``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># type: Tuple[Node, ...]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">text</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="n">dsl_error_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Infinite Loop detected.&#39;</span><span class="p">))</span>
            <span class="n">results</span> <span class="o">+=</span> <span class="p">(</span><span class="n">node</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="n">Alternative</span><span class="p">)</span>
                      <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span></div>


<div class="viewcode-block" id="OneOrMore"><a class="viewcode-back" href="../ModuleReference.html#parse.OneOrMore">[docs]</a><span class="k">class</span> <span class="nc">OneOrMore</span><span class="p">(</span><span class="n">UnaryOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `OneOrMore` applies a parser repeatedly as long as this parser</span>
<span class="sd">    matches. Other than `ZeroOrMore` which always matches, at least</span>
<span class="sd">    one match is required by `OneOrMore`.</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; sentence = OneOrMore(RE(r&#39;\w+,?&#39;)) + Token(&#39;.&#39;)</span>
<span class="sd">        &gt;&gt;&gt; Grammar(sentence)(&#39;Wo viel der Weisheit, da auch viel des Grämens.&#39;).content</span>
<span class="sd">        &#39;Wo viel der Weisheit, da auch viel des Grämens.&#39;</span>
<span class="sd">        &gt;&gt;&gt; str(Grammar(sentence)(&#39;.&#39;))  # an empty sentence also matches</span>
<span class="sd">        &#39; &lt;&lt;&lt; Error on &quot;.&quot; | Parser did not match! Invalid source file?\n    Most advanced: None\n    Last match:    None; &gt;&gt;&gt; &#39;</span>

<span class="sd">    EBNF-Notation: ``{ ... }+``</span>

<span class="sd">    EBNF-Example:  ``sentence = { /\w+,?/ }+``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">Option</span><span class="p">),</span> \
            <span class="s2">&quot;Use ZeroOrMore instead of nesting OneOrMore and Option: &quot;</span> \
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># type: Tuple[Node, ...]</span>
        <span class="n">text_</span> <span class="o">=</span> <span class="n">text</span>  <span class="c1"># type: StringView</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">text_</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_</span><span class="p">)</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">text_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">(</span><span class="n">text_</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="n">dsl_error_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Infinite Loop detected.&#39;</span><span class="p">))</span>
            <span class="n">results</span> <span class="o">+=</span> <span class="p">(</span><span class="n">node</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">results</span> <span class="o">==</span> <span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>
        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span> <span class="n">text_</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="n">Alternative</span><span class="p">)</span>
                      <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;}+&#39;</span></div>


<div class="viewcode-block" id="Series"><a class="viewcode-back" href="../ModuleReference.html#parse.Series">[docs]</a><span class="k">class</span> <span class="nc">Series</span><span class="p">(</span><span class="n">NaryOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches if each of a series of parsers matches exactly in the order of</span>
<span class="sd">    the series.</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; variable_name = RegExp(&#39;(?!\d)\w&#39;) + RE(&#39;\w*&#39;)</span>
<span class="sd">        &gt;&gt;&gt; Grammar(variable_name)(&#39;variable_1&#39;).content</span>
<span class="sd">        &#39;variable_1&#39;</span>
<span class="sd">        &gt;&gt;&gt; str(Grammar(variable_name)(&#39;1_variable&#39;))</span>
<span class="sd">        &#39; &lt;&lt;&lt; Error on &quot;1_variable&quot; | Parser did not match! Invalid source file?\n    Most advanced: None\n    Last match:    None; &gt;&gt;&gt; &#39;</span>

<span class="sd">    EBNF-Notation: ``... ...``    (sequence of parsers separated by a blank or new line)</span>

<span class="sd">    EBNF-Example:  ``series = letter letter_or_digit``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">RX_ARGUMENT</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s(\S)&#39;</span><span class="p">)</span>
    <span class="n">NOPE</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parsers</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">mandatory</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">NOPE</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">parsers</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">)</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">Series</span><span class="o">.</span><span class="n">NOPE</span><span class="p">,</span> \
            <span class="s1">&#39;Length </span><span class="si">%i</span><span class="s1"> of series exceeds maximum length of </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">Series</span><span class="o">.</span><span class="n">NOPE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mandatory</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mandatory</span> <span class="o">+=</span> <span class="n">length</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">mandatory</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="ow">or</span> <span class="n">mandatory</span> <span class="o">==</span> <span class="n">Series</span><span class="o">.</span><span class="n">NOPE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mandatory</span> <span class="o">=</span> <span class="n">mandatory</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">parsers</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">parsers</span><span class="p">,</span> <span class="n">mandatory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mandatory</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># type: Tuple[Node, ...]</span>
        <span class="n">text_</span> <span class="o">=</span> <span class="n">text</span>  <span class="c1"># type: StringView</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">text_</span> <span class="o">=</span> <span class="n">parser</span><span class="p">(</span><span class="n">text_</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mandatory</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Provide useful error messages</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">RX_ARGUMENT</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">regs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="k">if</span> <span class="n">match</span> <span class="k">else</span> <span class="mi">1</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text_</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">init_pos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">document_length__</span>
                                                          <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_</span><span class="p">))</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> expected; &quot;</span><span class="si">%s</span><span class="s1">&quot;... found!&#39;</span>
                                   <span class="o">%</span> <span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span><span class="p">,</span> <span class="n">text_</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n &#39;</span><span class="p">)),</span>
                                   <span class="n">code</span><span class="o">=</span><span class="n">Error</span><span class="o">.</span><span class="n">MANDATORY_CONTINUATION</span><span class="p">)</span>
                    <span class="n">text_</span> <span class="o">=</span> <span class="n">text_</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
            <span class="n">results</span> <span class="o">+=</span> <span class="p">(</span><span class="n">node</span><span class="p">,)</span>
            <span class="c1"># if node.error_flag:  # break on first error</span>
            <span class="c1">#    break</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span> <span class="n">text_</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span> <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">mandatory</span><span class="p">]]</span>
                        <span class="o">+</span> <span class="p">([</span><span class="s1">&#39;§&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mandatory</span> <span class="o">!=</span> <span class="n">Series</span><span class="o">.</span><span class="n">NOPE</span> <span class="k">else</span> <span class="p">[])</span>
                        <span class="o">+</span> <span class="p">[</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span> <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mandatory</span><span class="p">:]])</span>

    <span class="c1"># The following operator definitions add syntactical sugar, so one can write:</span>
    <span class="c1"># `RE(&#39;\d+&#39;) + Optional(RE(&#39;\.\d+)` instead of `Series(RE(&#39;\d+&#39;), Optional(RE(&#39;\.\d+))`</span>

<div class="viewcode-block" id="Series.combined_mandatory"><a class="viewcode-back" href="../ModuleReference.html#parse.Series.combined_mandatory">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combined_mandatory</span><span class="p">(</span><span class="n">left</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Parser</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the position of the first mandatory element (if any) when</span>
<span class="sd">        parsers `left` and `right` are joined to a sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_mandatory</span><span class="p">,</span> <span class="n">left_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">mandatory</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">parsers</span><span class="p">))</span> \
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">NOPE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left_mandatory</span> <span class="o">!=</span> <span class="n">Series</span><span class="o">.</span><span class="n">NOPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left_mandatory</span>
        <span class="n">right_mandatory</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">mandatory</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> <span class="k">else</span> <span class="n">Series</span><span class="o">.</span><span class="n">NOPE</span>
        <span class="k">if</span> <span class="n">right_mandatory</span> <span class="o">!=</span> <span class="n">Series</span><span class="o">.</span><span class="n">NOPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">right_mandatory</span> <span class="o">+</span> <span class="n">left_length</span>
        <span class="k">return</span> <span class="n">Series</span><span class="o">.</span><span class="n">NOPE</span></div>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Parser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="n">other_parsers</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s1">&#39;Series&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">parsers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> \
            <span class="k">else</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Parser</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="p">(</span><span class="n">other</span><span class="p">,))</span>  <span class="c1"># type: Tuple[Parser, ...]</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span> <span class="o">+</span> <span class="n">other_parsers</span><span class="p">),</span>
                      <span class="n">mandatory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_mandatory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Parser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="n">other_parsers</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s1">&#39;Series&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">parsers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> \
            <span class="k">else</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Parser</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="p">(</span><span class="n">other</span><span class="p">,))</span>  <span class="c1"># type: Tuple[Parser, ...]</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">other_parsers</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">),</span>
                      <span class="n">mandatory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_mandatory</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Parser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="n">other_parsers</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s1">&#39;Series&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">parsers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> \
            <span class="k">else</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Parser</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="p">(</span><span class="n">other</span><span class="p">,))</span>  <span class="c1"># type: Tuple[Parser, ...]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span> <span class="o">+=</span> <span class="n">other_parsers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mandatory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_mandatory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Alternative"><a class="viewcode-back" href="../ModuleReference.html#parse.Alternative">[docs]</a><span class="k">class</span> <span class="nc">Alternative</span><span class="p">(</span><span class="n">NaryOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches if one of several alternatives matches. Returns</span>
<span class="sd">    the first match.</span>

<span class="sd">    This parser represents the EBNF-operator &quot;|&quot; with the qualification</span>
<span class="sd">    that both the symmetry and the ambiguity of the EBNF-or-operator</span>
<span class="sd">    are broken by selecting the first match.::</span>

<span class="sd">        # the order of the sub-expression matters!</span>
<span class="sd">        &gt;&gt;&gt; number = RE(&#39;\d+&#39;) | RE(&#39;\d+&#39;) + RE(&#39;\.&#39;) + RE(&#39;\d+&#39;)</span>
<span class="sd">        &gt;&gt;&gt; str(Grammar(number)(&quot;3.1416&quot;))</span>
<span class="sd">        &#39;3 &lt;&lt;&lt; Error on &quot;.141&quot; | Parser stopped before end! trying to recover... &gt;&gt;&gt; &#39;</span>

<span class="sd">        # the most selective expression should be put first:</span>
<span class="sd">        &gt;&gt;&gt; number = RE(&#39;\d+&#39;) + RE(&#39;\.&#39;) + RE(&#39;\d+&#39;) | RE(&#39;\d+&#39;)</span>
<span class="sd">        &gt;&gt;&gt; Grammar(number)(&quot;3.1416&quot;).content</span>
<span class="sd">        &#39;3.1416&#39;</span>

<span class="sd">    EBNF-Notation: ``... | ...``</span>

<span class="sd">    EBNF-Example:  ``sentence = /\d+\.\d+/ | /\d+/``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parsers</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">parsers</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>
        <span class="c1"># only the last alternative may be optional. Could this be checked at compile time?</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Option</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> \
            <span class="s2">&quot;Parser-specification Error: only the last alternative may be optional!&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">text_</span> <span class="o">=</span> <span class="n">parser</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">),</span> <span class="n">text_</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span> <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

<div class="viewcode-block" id="Alternative.reset"><a class="viewcode-back" href="../ModuleReference.html#parse.Alternative.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Alternative</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># The following operator definitions add syntactical sugar, so one can write:</span>
    <span class="c1"># `RE(&#39;\d+&#39;) + RE(&#39;\.&#39;) + RE(&#39;\d+&#39;) | RE(&#39;\d+&#39;)` instead of:</span>
    <span class="c1"># `Alternative(Series(RE(&#39;\d+&#39;), RE(&#39;\.&#39;), RE(&#39;\d+&#39;)), RE(&#39;\d+&#39;))`</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Parser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Alternative&#39;</span><span class="p">:</span>
        <span class="n">other_parsers</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s1">&#39;Alternative&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">parsers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Alternative</span><span class="p">)</span> \
            <span class="k">else</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Parser</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="p">(</span><span class="n">other</span><span class="p">,))</span>  <span class="c1"># type: Tuple[Parser, ...]</span>
        <span class="k">return</span> <span class="n">Alternative</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span> <span class="o">+</span> <span class="n">other_parsers</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Parser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Alternative&#39;</span><span class="p">:</span>
        <span class="n">other_parsers</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s1">&#39;Alternative&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">parsers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Alternative</span><span class="p">)</span> \
            <span class="k">else</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Parser</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="p">(</span><span class="n">other</span><span class="p">,))</span>  <span class="c1"># type: Tuple[Parser, ...]</span>
        <span class="k">return</span> <span class="n">Alternative</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">other_parsers</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Parser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Alternative&#39;</span><span class="p">:</span>
        <span class="n">other_parsers</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s1">&#39;Alternative&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">parsers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Alternative</span><span class="p">)</span> \
            <span class="k">else</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Parser</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="p">(</span><span class="n">other</span><span class="p">,))</span>  <span class="c1"># type: Tuple[Parser, ...]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span> <span class="o">+=</span> <span class="n">other_parsers</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="AllOf"><a class="viewcode-back" href="../ModuleReference.html#parse.AllOf">[docs]</a><span class="k">class</span> <span class="nc">AllOf</span><span class="p">(</span><span class="n">NaryOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches if all elements of a list of parsers match. Each parser must</span>
<span class="sd">    match exactly once. Other than in a sequence, the order in which</span>
<span class="sd">    the parsers match is arbitrary, however.</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; prefixes = AllOf(Token(&quot;A&quot;), Token(&quot;B&quot;))</span>
<span class="sd">        &gt;&gt;&gt; Grammar(prefixes)(&#39;A B&#39;).content</span>
<span class="sd">        &#39;A B&#39;</span>
<span class="sd">        &gt;&gt;&gt; Grammar(prefixes)(&#39;B A&#39;).content</span>
<span class="sd">        &#39;B A&#39;</span>

<span class="sd">    EBNF-Notation: ``&lt;... ...&gt;``    (sequence of parsers enclosed by angular brackets)</span>

<span class="sd">    EBNF-Example:  ``set = &lt;letter letter_or_digit&gt;``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parsers</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parsers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parsers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parsers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Series</span><span class="p">),</span> \
                <span class="s2">&quot;Parser-specification Error: No single arguments other than a Series &quot;</span> \
                <span class="s2">&quot;allowed as arguments for AllOf-Parser !&quot;</span>
            <span class="n">series</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">parsers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">series</span><span class="o">.</span><span class="n">mandatory</span> <span class="o">==</span> <span class="n">Series</span><span class="o">.</span><span class="n">NOPE</span><span class="p">,</span> \
                <span class="s2">&quot;AllOf cannot contain mandatory (§) elements!&quot;</span>
            <span class="n">parsers</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">parsers</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">parsers</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># type: Tuple[Node, ...]</span>
        <span class="n">text_</span> <span class="o">=</span> <span class="n">text</span>  <span class="c1"># type: StringView</span>
        <span class="n">parsers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">)</span>  <span class="c1"># type: List[Parser]</span>
        <span class="k">while</span> <span class="n">parsers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">parser</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parsers</span><span class="p">):</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">text__</span> <span class="o">=</span> <span class="n">parser</span><span class="p">(</span><span class="n">text_</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                    <span class="n">results</span> <span class="o">+=</span> <span class="p">(</span><span class="n">node</span><span class="p">,)</span>
                    <span class="n">text_</span> <span class="o">=</span> <span class="n">text__</span>
                    <span class="k">del</span> <span class="n">parsers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span> <span class="n">text_</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span> <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span></div>


<div class="viewcode-block" id="SomeOf"><a class="viewcode-back" href="../ModuleReference.html#parse.SomeOf">[docs]</a><span class="k">class</span> <span class="nc">SomeOf</span><span class="p">(</span><span class="n">NaryOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches if at least one element of a list of parsers match. No parser</span>
<span class="sd">    must match more than once . Other than in a sequence, the order in which</span>
<span class="sd">    the parsers match is arbitrary, however.</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; prefixes = SomeOf(Token(&quot;A&quot;), Token(&quot;B&quot;))</span>
<span class="sd">        &gt;&gt;&gt; Grammar(prefixes)(&#39;A B&#39;).content</span>
<span class="sd">        &#39;A B&#39;</span>
<span class="sd">        &gt;&gt;&gt; Grammar(prefixes)(&#39;B A&#39;).content</span>
<span class="sd">        &#39;B A&#39;</span>
<span class="sd">        &gt;&gt;&gt; Grammar(prefixes)(&#39;B&#39;).content</span>
<span class="sd">        &#39;B&#39;</span>

<span class="sd">    EBNF-Notation: ``&lt;... ...&gt;``    (sequence of parsers enclosed by angular brackets)</span>

<span class="sd">    EBNF-Example:  ``set = &lt;letter letter_or_digit&gt;``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parsers</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parsers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parsers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Alternative</span><span class="p">),</span> \
                <span class="s2">&quot;Parser-specification Error: No single arguments other than a Alternative &quot;</span> \
                <span class="s2">&quot;allowed as arguments for SomeOf-Parser !&quot;</span>
            <span class="n">alternative</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Alternative</span><span class="p">,</span> <span class="n">parsers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">parsers</span> <span class="o">=</span> <span class="n">alternative</span><span class="o">.</span><span class="n">parsers</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">parsers</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># type: Tuple[Node, ...]</span>
        <span class="n">text_</span> <span class="o">=</span> <span class="n">text</span>  <span class="c1"># type: StringView</span>
        <span class="n">parsers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">)</span>  <span class="c1"># type: List[Parser]</span>
        <span class="k">while</span> <span class="n">parsers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">parser</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parsers</span><span class="p">):</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">text__</span> <span class="o">=</span> <span class="n">parser</span><span class="p">(</span><span class="n">text_</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                    <span class="n">results</span> <span class="o">+=</span> <span class="p">(</span><span class="n">node</span><span class="p">,)</span>
                    <span class="n">text_</span> <span class="o">=</span> <span class="n">text__</span>
                    <span class="k">del</span> <span class="n">parsers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parsers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span> <span class="n">text_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span> <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span></div>


<div class="viewcode-block" id="Unordered"><a class="viewcode-back" href="../ModuleReference.html#parse.Unordered">[docs]</a><span class="k">def</span> <span class="nf">Unordered</span><span class="p">(</span><span class="n">parser</span><span class="p">:</span> <span class="n">NaryOperator</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NaryOperator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an AllOf- or SomeOf-parser depending on whether `parser`</span>
<span class="sd">    is a Series (AllOf) or an Alternative (SomeOf).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AllOf</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">Alternative</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SomeOf</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Unordered can take only Series or Alternative as parser.&quot;</span><span class="p">)</span></div>


<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># Flow control operators</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>

<span class="k">class</span> <span class="nc">FlowOperator</span><span class="p">(</span><span class="n">UnaryOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all flow operator parsers like Lookahead and Lookbehind.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bool_value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the value. Can be overriden to return the inverted bool.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bool_value</span>


<span class="c1"># class Required(FlowOperator):</span>
<span class="c1">#     &quot;&quot;&quot;OBSOLETE. Use mandatory-parameter of Series-parser instead!</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     RX_ARGUMENT = re.compile(r&#39;\s(\S)&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     def __call__(self, text: StringView) -&gt; Tuple[Optional[Node], StringView]:</span>
<span class="c1">#         node, text_ = self.parser(text)</span>
<span class="c1">#         if not node:</span>
<span class="c1">#             m = text.search(Required.RX_ARGUMENT)  # re.search(r&#39;\s(\S)&#39;, text)</span>
<span class="c1">#             i = max(1, text.index(m.regs[1][0])) if m else 1</span>
<span class="c1">#             node = Node(self, text[:i])</span>
<span class="c1">#             text_ = text[i:]</span>
<span class="c1">#             node.add_error(&#39;%s expected; &quot;%s&quot; found!&#39; % (str(self.parser), text[:10]),</span>
<span class="c1">#                            code=Error.MANDATORY_CONTINUATION)</span>
<span class="c1">#         return node, text_</span>
<span class="c1">#</span>
<span class="c1">#     def __repr__(self):</span>
<span class="c1">#         return &#39;§&#39; + self.parser.repr</span>


<div class="viewcode-block" id="Lookahead"><a class="viewcode-back" href="../ModuleReference.html#parse.Lookahead">[docs]</a><span class="k">class</span> <span class="nc">Lookahead</span><span class="p">(</span><span class="n">FlowOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches, if the contained parser would match for the following text,</span>
<span class="sd">    but does not consume any text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="n">text</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&amp;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span></div>


<div class="viewcode-block" id="NegativeLookahead"><a class="viewcode-back" href="../ModuleReference.html#parse.NegativeLookahead">[docs]</a><span class="k">class</span> <span class="nc">NegativeLookahead</span><span class="p">(</span><span class="n">Lookahead</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches, if the contained parser would *not* match for the following</span>
<span class="sd">    text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;!&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span>

<div class="viewcode-block" id="NegativeLookahead.sign"><a class="viewcode-back" href="../ModuleReference.html#parse.NegativeLookahead.sign">[docs]</a>    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bool_value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">bool_value</span></div></div>


<div class="viewcode-block" id="Lookbehind"><a class="viewcode-back" href="../ModuleReference.html#parse.Lookbehind">[docs]</a><span class="k">class</span> <span class="nc">Lookbehind</span><span class="p">(</span><span class="n">FlowOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches, if the contained parser would match backwards. Requires</span>
<span class="sd">    the contained parser to be a RegExp, RE, PlainText or Token parser.</span>

<span class="sd">    EXPERIMENTAL</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Synonym</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parser</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RegExp</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PlainText</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RE</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regexp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RE</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">RE</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">main</span><span class="p">,</span> <span class="n">RegExp</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">regexp</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">RegExp</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="n">RE</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">main</span><span class="p">)</span><span class="o">.</span><span class="n">regexp</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># p.main is of type PlainText</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">PlainText</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="n">RE</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">main</span><span class="p">)</span><span class="o">.</span><span class="n">text</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RegExp</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regexp</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">RegExp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">regexp</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># p is of type PlainText</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">PlainText</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">text</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">backwards_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">reversed__</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regexp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># assert self.text is not None</span>
            <span class="n">does_match</span> <span class="o">=</span> <span class="n">backwards_text</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">)]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># assert self.regexp is not None</span>
            <span class="n">does_match</span> <span class="o">=</span> <span class="n">backwards_text</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regexp</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="n">text</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">does_match</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;-&amp;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span></div>


<div class="viewcode-block" id="NegativeLookbehind"><a class="viewcode-back" href="../ModuleReference.html#parse.NegativeLookbehind">[docs]</a><span class="k">class</span> <span class="nc">NegativeLookbehind</span><span class="p">(</span><span class="n">Lookbehind</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches, if the contained parser would *not* match backwards. Requires</span>
<span class="sd">    the contained parser to be a RegExp-parser.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;-!&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span>

<div class="viewcode-block" id="NegativeLookbehind.sign"><a class="viewcode-back" href="../ModuleReference.html#parse.NegativeLookbehind.sign">[docs]</a>    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bool_value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">bool_value</span><span class="p">)</span></div></div>


<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># Capture and Retrieve operators (for passing variables in the parser)</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>


<div class="viewcode-block" id="Capture"><a class="viewcode-back" href="../ModuleReference.html#parse.Capture">[docs]</a><span class="k">class</span> <span class="nc">Capture</span><span class="p">(</span><span class="n">UnaryOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies the contained parser and, in case of a match, saves the result</span>
<span class="sd">    in a variable. A variable is a stack of values associated with the</span>
<span class="sd">    contained parser&#39;s name. This requires the contained parser to be named.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">text_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Tried to apply an unnamed capture-parser!&quot;&quot;&quot;</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">variables__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
            <span class="n">location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">document_length__</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">push_rollback__</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
            <span class="c1"># caching will be blocked by parser guard (see way above),</span>
            <span class="c1"># because it would prevent recapturing of rolled back captures</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">),</span> <span class="n">text_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span></div>


<span class="n">RetrieveFilter</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">str</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">last_value</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">counterpart</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;{&quot;</span><span class="p">,</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">accumulate</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># provoke IndexError if stack empty</span>


<div class="viewcode-block" id="Retrieve"><a class="viewcode-back" href="../ModuleReference.html#parse.Retrieve">[docs]</a><span class="k">class</span> <span class="nc">Retrieve</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches if the following text starts with the value of a particular</span>
<span class="sd">    variable. As a variable in this context means a stack of values,</span>
<span class="sd">    the last value will be compared with the following text. It will not</span>
<span class="sd">    be removed from the stack! (This is the difference between the</span>
<span class="sd">    `Retrieve` and the `Pop` parser.)</span>
<span class="sd">    The constructor parameter `symbol` determines which variable is</span>
<span class="sd">    used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">rfilter</span><span class="p">:</span> <span class="n">RetrieveFilter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Retrieve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="n">symbol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">rfilter</span> <span class="k">if</span> <span class="n">rfilter</span> <span class="k">else</span> <span class="n">last_value</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="c1"># the following indirection allows the call() method to be called</span>
        <span class="c1"># from subclass without triggering the parser guard a second time</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrieve_and_match</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">repr</span>

<div class="viewcode-block" id="Retrieve.retrieve_and_match"><a class="viewcode-back" href="../ModuleReference.html#parse.Retrieve.retrieve_and_match">[docs]</a>    <span class="k">def</span> <span class="nf">retrieve_and_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves variable from stack through the filter function passed to</span>
<span class="sd">        the class&#39; constructor and tries to match the variable&#39;s value with</span>
<span class="sd">        the following text. Returns a Node containing the value or `None`</span>
<span class="sd">        accordingly.</span>

<span class="sd">        This functionality has been move from the __call__ method to an</span>
<span class="sd">        independent method to allow calling it from a subclasses __call__</span>
<span class="sd">        method without triggering the parser guard a second time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">variables__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span>
                <span class="n">dsl_error_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; undefined or exhausted.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">)),</span> <span class="n">text</span>
        <span class="k">if</span> <span class="n">text</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">text</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span></div></div>


<div class="viewcode-block" id="Pop"><a class="viewcode-back" href="../ModuleReference.html#parse.Pop">[docs]</a><span class="k">class</span> <span class="nc">Pop</span><span class="p">(</span><span class="n">Retrieve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches if the following text starts with the value of a particular</span>
<span class="sd">    variable. As a variable in this context means a stack of values,</span>
<span class="sd">    the last value will be compared with the following text. Other</span>
<span class="sd">    than the `Retrieve`-parser, the `Pop`-parser removes the value</span>
<span class="sd">    from the stack in case of a match.</span>

<span class="sd">    The constructor parameter `symbol` determines which variable is</span>
<span class="sd">    used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">txt</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">retrieve_and_match</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">error_flag</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">variables__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">document_length__</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">push_rollback__</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="n">txt</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;::&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">repr</span></div>


<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># Aliasing parser classes</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>


<div class="viewcode-block" id="Synonym"><a class="viewcode-back" href="../ModuleReference.html#parse.Synonym">[docs]</a><span class="k">class</span> <span class="nc">Synonym</span><span class="p">(</span><span class="n">UnaryOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simply calls another parser and encapsulates the result in</span>
<span class="sd">    another node if that parser matches.</span>

<span class="sd">    This parser is needed to support synonyms in EBNF, e.g.::</span>

<span class="sd">        jahr       = JAHRESZAHL</span>
<span class="sd">        JAHRESZAHL = /\d\d\d\d/</span>

<span class="sd">    Otherwise the first line could not be represented by any parser</span>
<span class="sd">    class, in which case it would be unclear whether the parser</span>
<span class="sd">    RE(&#39;\d\d\d\d&#39;) carries the name &#39;JAHRESZAHL&#39; or &#39;jahr&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">),</span> <span class="n">text</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">repr</span></div>


<div class="viewcode-block" id="Forward"><a class="viewcode-back" href="../ModuleReference.html#parse.Forward">[docs]</a><span class="k">class</span> <span class="nc">Forward</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Forward allows to declare a parser before it is actually defined.</span>
<span class="sd">    Forward declarations are needed for parsers that are recursively</span>
<span class="sd">    nested, e.g.::</span>

<span class="sd">        class Arithmetic(Grammar):</span>
<span class="sd">            &#39;&#39;&#39;</span>
<span class="sd">            expression =  term  { (&quot;+&quot; | &quot;-&quot;) term }</span>
<span class="sd">            term       =  factor  { (&quot;*&quot; | &quot;/&quot;) factor }</span>
<span class="sd">            factor     =  INTEGER | &quot;(&quot;  expression  &quot;)&quot;</span>
<span class="sd">            INTEGER    =  /\d+/~</span>
<span class="sd">            &#39;&#39;&#39;</span>
<span class="sd">            expression = Forward()</span>
<span class="sd">            INTEGER    = RE(&#39;\\d+&#39;)</span>
<span class="sd">            factor     = INTEGER | Token(&quot;(&quot;) + expression + Token(&quot;)&quot;)</span>
<span class="sd">            term       = factor + ZeroOrMore((Token(&quot;*&quot;) | Token(&quot;/&quot;)) + factor)</span>
<span class="sd">            expression.set(term + ZeroOrMore((Token(&quot;+&quot;) | Token(&quot;-&quot;)) + term))</span>
<span class="sd">            root__     = expression</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Parser</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cycle_reached</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">duplicate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">duplicate</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">duplicate</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">duplicate</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">StringView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">StringView</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__cycle_guard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">alt_return</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value of `func()` or `alt_return` if a cycle has</span>
<span class="sd">        been reached (which can happen if `func` calls methods of</span>
<span class="sd">        child parsers).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycle_reached</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">alt_return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cycle_reached</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cycle_reached</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cycle_guard</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">),</span> <span class="s1">&#39;...&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cycle_guard</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">),</span> <span class="s1">&#39;...&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Forward.set"><a class="viewcode-back" href="../ModuleReference.html#parse.Forward.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the parser to which the calls to this Forward-object</span>
<span class="sd">        shall be delegated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">parser</span></div>

<div class="viewcode-block" id="Forward.apply"><a class="viewcode-back" href="../ModuleReference.html#parse.Forward.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Parser</span><span class="o">.</span><span class="n">ApplyFunc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div></div>



</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Eckhart Arnold.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.8',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>