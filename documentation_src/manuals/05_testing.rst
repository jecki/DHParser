Testing
=======

DHParser provides a powerful unit-testing framework that allows testing 
individual components of a grammar separately through all stages of
the :ref:`processing pipeline <processing_pipelines>`. DHParser's 
unit-testing framework allows to::

    - break down the complicated process of writing a grammar into
      relatively simpler tasks of designing grammar-components each
      of which can be tested individually

    - turn writing and refactoring grammars into controlled and 
      manageable process. In fact, without unit-testing, refactoring
      of grammars is hardly feasible at all.

    - extend a grammar incrementally without breaking existing code.

    - check the syntax-tree-construction as well as all subsequent
      transformations (as long as their result is serializable).
      
Because writing grammars can be difficult, refactoring and testing of
grammars is crucial for the success of a project. Also, one and the
same formal language can be described by different grammars and the way
the grammar is written influences the shape of the syntax-tree that the
parser yields. Therefore, it is quite common to rewrite a grammar or
parts of it more than once during the course of developing a formal
notatation. For example, in the first iteration one tries to find a
grammar that matches the given or inteded notation. In the second
iteration, the grammar is refined to yield a well-shaped syntax-tree to
make further processing easier. Unit-tests help to safeguard this
process against breaking earlier changes by later changes.

Writing grammar-tests
---------------------

The canical way to write grammar-tests in a DHParser-projects is by
writing them into a file with a name that matches the the
glob-pattern ``*_test_*.ini``. Tests can then simply be executed by
running the ``tst_..._grammar.py``-script that has been generated by
the dhparser-command (see :ref:`full_scale_DSLs`). The format of these
files strongly resembles that of common config-files. Here is a test 
for the outline-parser example from the overview (:ref:`macros`):: 

    [match:document]
    M1: """# Main Heading
        ## Section 1
        ### SubSection 1.1
        ### SubSection 1.2
        ## Section 2"""

    [fail:document]
    F1: """# Main Heading
        ## Section 1
        #### SubSubSection 1.1.1  BADLY NESTED!!! 
        ### SubSection 1.2
        ## Section 2"""

Test-files are separated into sections by headings that are enclosed
in square-brackets, i.e. ``[`` and ``]``. The heading's name consists
of two parts, separeted by a colon ``:``. The first part indicates the
kind of the tests that are specified under the heading. The second
part is the name of the parser that will be called with these tests
as input. Thus, the heading "[match:document]" means that the following
tests will be feeded to the parser "document" and the parser is expected
to match. The following heading "[fail:document]" introduces tests,
where the parser "document" is expected to fail, i.e. the test is 
successful if the parser does not match the snipped fed to the parser.

The tests themselves are specified by a name followed by a colon ``:`` 
followd by a single-line or multiline-string which line Python-strings
can be enclosed in single or tripple single-quotation-marks ``'`` or 
double quotation-marks ``"``. *Multi-line-strings must always be indented
by four spaces for all lines except the first line!* (The intentation
will automatically be removed before running the test.) 

.. attention:: The names for fail-test must differ from the names of
    match tests! One way to do so is the mark the test with a special
    letter like "M" for match-test and "F" for fail-tests, respectively.
    E.G.: "M1", "M2", "M3", ... and "F1", "F2", "F3", ...


Running grammar-tests
---------------------

Grammar tests can be run either by calling the (auto-generated) 
test-grammar script with the filename of the test-file as argument.
Alternatively, the script can be run without any arguments, in which
case it will look for a "test_grammar" folder inside the 
current-directory and then run all test-files in this directory, where
any file is considered a test-file the name of which matches the
glob-pattern ``*_test_*.ini``. 

.. tip:: It is a good idea to add the DHParser-projects's 
    ``tst_..._grammar.py``-script to the executable tools
    of your Python-IDE. Then it suffices to simply point to
    the test in the IDE's file-manager and pick the tool
    from the menu to run a particular test. 
    
    This works pretty 
    well with PyCharm, but should also be possible with other
    integrated development environments or code-editors.


